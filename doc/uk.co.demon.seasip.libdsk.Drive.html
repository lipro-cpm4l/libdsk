<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Sat Apr 06 23:51:09 GMT 2002 -->
<title>
  Class uk.co.demon.seasip.libdsk.Drive
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-uk.co.demon.seasip.libdsk.html">This Package</a>  <a href="Package-uk.co.demon.seasip.libdsk.html">Previous</a>  <a href="uk.co.demon.seasip.libdsk.FormatData.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class uk.co.demon.seasip.libdsk.Drive
</h1>
<pre>
java.lang.Object
   |
   +----uk.co.demon.seasip.libdsk.Drive
</pre>
<hr>
<dl>
  <dt> public class <b>Drive</b>
  <dt> extends Object
</dl>
The Drive class represents an open LibDsk drive.
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/variable-index.gif" width=207 height=38 alt="Variable Index">
</h2>
<dl>
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSK_ST3_DSDRIVE"><b>DSK_ST3_DSDRIVE</b></a>
  <dd> When returned by status(), indicates the drive is double-sided.
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSK_ST3_FAULT"><b>DSK_ST3_FAULT</b></a>
  <dd> When returned by status(), indicates drive fault.
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSK_ST3_HEAD1"><b>DSK_ST3_HEAD1</b></a>
  <dd> When returned by status(), indicates the current head is head 1.
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSK_ST3_READY"><b>DSK_ST3_READY</b></a>
  <dd> When returned by status(), indicates the drive is ready.
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSK_ST3_RO"><b>DSK_ST3_RO</b></a>
  <dd> When returned by status(), indicates disc read only.
  <dt> <img src="images/blue-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#DSK_ST3_TRACK0"><b>DSK_ST3_TRACK0</b></a>
  <dd> When returned by status(), indicates the head is over track 0.
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#autoFormat(uk.co.demon.seasip.libdsk.Geometry, int, byte)"><b>autoFormat</b></a>(Geometry, int, byte)
  <dd> Format a track, generating the sector headers automatically.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#autoFormat(uk.co.demon.seasip.libdsk.Geometry, int, int, byte)"><b>autoFormat</b></a>(Geometry, int, int, byte)
  <dd> Format a track, generating the sector headers automatically.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#close()"><b>close</b></a>()
  <dd> Close a DSK file.
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#enumDrivers(int)"><b>enumDrivers</b></a>(int)
  <dd> Get the name of a built-in driver.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#format(uk.co.demon.seasip.libdsk.Geometry, int, uk.co.demon.seasip.libdsk.FormatData[], byte)"><b>format</b></a>(Geometry, int, FormatData[], byte)
  <dd> Format a track, generating the sector headers automatically.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#format(uk.co.demon.seasip.libdsk.Geometry, int, int, uk.co.demon.seasip.libdsk.FormatData[], byte)"><b>format</b></a>(Geometry, int, int, FormatData[], byte)
  <dd> Format a track, using physical cylinder/sector.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getDriverDesc()"><b>getDriverDesc</b></a>()
  <dd> Get the description of the driver being used for this drive.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getDriverName()"><b>getDriverName</b></a>()
  <dd> Get the name of the driver being used for this drive.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#getForceHead()"><b>getForceHead</b></a>()
  <dd> Find out if the drive is being forced to use one or other head.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#probeGeometry(uk.co.demon.seasip.libdsk.Geometry)"><b>probeGeometry</b></a>(Geometry)
  <dd> Probe the geometry of a disc.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#read(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><b>read</b></a>(Geometry, byte[], int)
  <dd> Read a disc sector using a logical sector address.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#read(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int)"><b>read</b></a>(Geometry, byte[], int, int, int)
  <dd> Read a disc sector using a physical sector address.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#read(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int, int, int)"><b>read</b></a>(Geometry, byte[], int, int, int, int, int, int)
  <dd> Read a disc sector whose numbering may not match its disc location.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#readTrack(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><b>readTrack</b></a>(Geometry, byte[], int)
  <dd> Read a track using a logical track number.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#readTrack(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int)"><b>readTrack</b></a>(Geometry, byte[], int, int)
  <dd> Read a track using a physical head/cylinder number.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#readTrack(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int)"><b>readTrack</b></a>(Geometry, byte[], int, int, int, int)
  <dd> Read a track whose sector headers may not match its location.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#sectorID(uk.co.demon.seasip.libdsk.Geometry, int, uk.co.demon.seasip.libdsk.FormatData)"><b>sectorID</b></a>(Geometry, int, FormatData)
  <dd> Read a random sector ID.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#sectorID(uk.co.demon.seasip.libdsk.Geometry, int, int, uk.co.demon.seasip.libdsk.FormatData)"><b>sectorID</b></a>(Geometry, int, int, FormatData)
  <dd> Read a random sector ID.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#seek(uk.co.demon.seasip.libdsk.Geometry, int)"><b>seek</b></a>(Geometry, int)
  <dd> Seek to a track using a logical track number.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#seek(uk.co.demon.seasip.libdsk.Geometry, int, int)"><b>seek</b></a>(Geometry, int, int)
  <dd> Seek to a track using a physical cylinder/head number.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#setForceHead(int)"><b>setForceHead</b></a>(int)
  <dd> Force the driver to use one or other head.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#status(uk.co.demon.seasip.libdsk.Geometry, int)"><b>status</b></a>(Geometry, int)
  <dd> Get the status of the drive.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#verify(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><b>verify</b></a>(Geometry, byte[], int)
  <dd> Verify a disc sector using a logical sector address.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#verify(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int)"><b>verify</b></a>(Geometry, byte[], int, int, int)
  <dd> Verify a disc sector using a physical sector address.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#verify(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int, int, int)"><b>verify</b></a>(Geometry, byte[], int, int, int, int, int, int)
  <dd> Verify a disc sector whose numbering may not match its disc location.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#write(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><b>write</b></a>(Geometry, byte[], int)
  <dd> Write a disc sector using a logical sector address.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#write(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int)"><b>write</b></a>(Geometry, byte[], int, int, int)
  <dd> Write a disc sector using a physical sector address.
  <dt> <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#write(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int, int, int)"><b>write</b></a>(Geometry, byte[], int, int, int, int, int, int)
  <dd> Write a disc sector whose numbering may not match its disc location.
</dl>
<a name="variables"></a>
<h2>
  <img src="images/variables.gif" width=153 height=38 alt="Variables">
</h2>
<a name="DSK_ST3_FAULT"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSK_ST3_FAULT</b>
<pre>
 public static final int DSK_ST3_FAULT
</pre>
<dl>
  <dd> When returned by status(), indicates drive fault.<p>
  <dd><dl> 
    <dt> <b>See Also:</b>
    <dd> <a href="#status">status</a>
  </dl></dd>
</dl>
<a name="DSK_ST3_RO"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSK_ST3_RO</b>
<pre>
 public static final int DSK_ST3_RO
</pre>
<dl>
  <dd> When returned by status(), indicates disc read only. *<p>
  <dd><dl> 
    <dt> <b>See Also:</b>
    <dd> <a href="#status">status</a>
  </dl></dd>
</dl>
<a name="DSK_ST3_READY"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSK_ST3_READY</b>
<pre>
 public static final int DSK_ST3_READY
</pre>
<dl>
  <dd> When returned by status(), indicates the drive is ready. *<p>
  <dd><dl> 
    <dt> <b>See Also:</b>
    <dd> <a href="#status">status</a>
  </dl></dd>
</dl>
<a name="DSK_ST3_TRACK0"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSK_ST3_TRACK0</b>
<pre>
 public static final int DSK_ST3_TRACK0
</pre>
<dl>
  <dd> When returned by status(), indicates the head is over track 0. *<p>
  <dd><dl> 
    <dt> <b>See Also:</b>
    <dd> <a href="#status">status</a>
  </dl></dd>
</dl>
<a name="DSK_ST3_DSDRIVE"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSK_ST3_DSDRIVE</b>
<pre>
 public static final int DSK_ST3_DSDRIVE
</pre>
<dl>
  <dd> When returned by status(), indicates the drive is double-sided. *<p>
  <dd><dl> 
    <dt> <b>See Also:</b>
    <dd> <a href="#status">status</a>
  </dl></dd>
</dl>
<a name="DSK_ST3_HEAD1"><img src="images/blue-ball.gif" width=12 height=12 alt=" o "></a>
<b>DSK_ST3_HEAD1</b>
<pre>
 public static final int DSK_ST3_HEAD1
</pre>
<dl>
  <dd> When returned by status(), indicates the current head is head 1. *<p>
  <dd><dl> 
    <dt> <b>See Also:</b>
    <dd> <a href="#status">status</a>
  </dl></dd>
</dl>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="setForceHead(int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="setForceHead"><b>setForceHead</b></a>
<pre>
 public native void setForceHead(int f)
</pre>
<dl>
  <dd> Force the driver to use one or other head. 
 <p>(This option is only effective for the Linux floppy driver)
 <p>Forces the driver to ignore the head number passed to it and 
 always use either side 0 or side 1 of the disc. This is used to 
 read discs recorded on PCW / CPC / Spectrum+3 add-on 3.5" drives. 
 Instead of the system software being programmed to use both sides 
 of the disc, a switch on the drive was used to set which side was 
 being used. Thus discs would end up with both sides saying they 
 were head 0.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> f - -1 for normal use, 0 to force head 0, 1 to force head 1.
  </dl></dd>
</dl>
<a name="getForceHead()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getForceHead"><b>getForceHead</b></a>
<pre>
 public native int getForceHead()
</pre>
<dl>
  <dd> Find out if the drive is being forced to use one or other head.
<p>
  <dd><dl>
    <dt> <b>Returns:</b>
    <dd> -1 for normal use, 0 to force head 0, 1 to force head 1.
  </dl></dd>
</dl>
<a name="close()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="close"><b>close</b></a>
<pre>
 public native void close() throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Close a DSK file. 
  After the underlying file has been closed, you may not use 
 this object further. Any attempt to use it will cause an 
 exception to be thrown.
<p>
  <dd><dl>
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the close failed for any reason.
  </dl></dd>
</dl>
<a name="status(uk.co.demon.seasip.libdsk.Geometry, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="status"><b>status</b></a>
<pre>
 public native byte status(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                           int head) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Get the status of the drive. Most drivers only implement the 
DSK_ST3_READY and DSK_ST3_RO bits.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The geometry to use for the drive.
    <dd> head - Which head to check (0 or 1).
    <dt> <b>Returns:</b>
    <dd> The drive status, in uPD765A format.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> if there was any error.
  </dl></dd>
</dl>
<a name="read(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="read"><b>read</b></a>
<pre>
 public native void read(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                         byte buf[],
                         int cyl,
                         int head,
                         int sector) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a disc sector using a physical sector address.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The buffer to be filled with data.
    <dd> cyl - The physical cylinder containing the sector.
    <dd> head - The physical head to use.
    <dd> sector - The number of the sector.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason, or the driver
                     cannot read sectors.
  </dl></dd>
</dl>
<a name="read(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="read"><b>read</b></a>
<pre>
 public native void read(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                         byte buf[],
                         int logsect) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a disc sector using a logical sector address.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use. This will be used to translate the
         sector number to a physical cylinder/head/sector.
    <dd> buf - The buffer to be filled with data.
    <dd> logsect - The number of the sector (0 is the first sector on the disc).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason, or the driver cannot
                     read sectors.
  </dl></dd>
</dl>
<a name="read(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="read"><b>read</b></a>
<pre>
 public native void read(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                         byte buf[],
                         int cyl,
                         int head,
                         int cylExpected,
                         int headExpected,
                         int sector,
                         int sectorLen) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a disc sector whose numbering may not match its disc location.
 Not all drivers implement this function; those that don't will throw
 a DskException with error DSK_ERR_NOTIMPL.
 <p>Unless you are emulating a floppy controller, you should not need to 
 use this call.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The buffer to be filled with data.
    <dd> cyl - The physical cylinder containing the sector.
    <dd> head - The physical head to use.
    <dd> cylExpected - The expected cylinder number in the sector header.
    <dd> cylExpected - The expected head number in the sector header.
    <dd> sector - The number of the sector.
    <dd> sectorLen - The number of bytes to transfer (may be less than a
                 full sector).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason, or the driver
                  does not provide this call.
  </dl></dd>
</dl>
<a name="write(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="write"><b>write</b></a>
<pre>
 public native void write(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                          byte buf[],
                          int cyl,
                          int head,
                          int sector) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Write a disc sector using a physical sector address.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The data to be written.
    <dd> cyl - The physical cylinder containing the sector.
    <dd> head - The physical head to use.
    <dd> sector - The number of the sector.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the write failed for any reason, or the driver
                     cannot write sectors.
  </dl></dd>
</dl>
<a name="write(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="write"><b>write</b></a>
<pre>
 public native void write(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                          byte buf[],
                          int logsect) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Write a disc sector using a logical sector address.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use. This will be used to translate the
         sector number to a physical cylinder/head/sector.
    <dd> buf - The data to be written.
    <dd> logsect - The number of the sector (0 is the first sector on the disc).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the write failed for any reason, or the driver cannot
                     write sectors.
  </dl></dd>
</dl>
<a name="write(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="write"><b>write</b></a>
<pre>
 public native void write(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                          byte buf[],
                          int cyl,
                          int head,
                          int cylExpected,
                          int headExpected,
                          int sector,
                          int sectorLen) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Write a disc sector whose numbering may not match its disc location.
 Not all drivers implement this function; those that don't will throw
 a DskException with error DSK_ERR_NOTIMPL.
 <p>Unless you are emulating a floppy controller, you should not need to 
 use this call.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The data to be written.
    <dd> cyl - The physical cylinder containing the sector.
    <dd> head - The physical head to use.
    <dd> cylExpected - The expected cylinder number in the sector header.
    <dd> cylExpected - The expected head number in the sector header.
    <dd> sector - The number of the sector.
    <dd> sectorLen - The number of bytes to transfer (may be less than a
                 full sector).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the write failed for any reason, or the driver
                     does not provide this functionality.
  </dl></dd>
</dl>
<a name="verify(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="verify"><b>verify</b></a>
<pre>
 public native void verify(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                           byte buf[],
                           int cyl,
                           int head,
                           int sector) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Verify a disc sector using a physical sector address.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The buffer to compare with what's on the disc.
    <dd> cyl - The physical cylinder containing the sector.
    <dd> head - The physical head to use.
    <dd> sector - The number of the sector.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason; DSK_ERR_MISMATCH
                     if the data read don't match the buffer.
  </dl></dd>
</dl>
<a name="verify(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="verify"><b>verify</b></a>
<pre>
 public native void verify(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                           byte buf[],
                           int logsect) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Verify a disc sector using a logical sector address.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use. This will be used to translate the
         sector number to a physical cylinder/head/sector.
    <dd> buf - The buffer to compare with what's on the disc.
    <dd> logsect - The number of the sector (0 is the first sector on the disc).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason; DSK_ERR_MISMATCH
                     if the data read don't match the buffer.
  </dl></dd>
</dl>
<a name="verify(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="verify"><b>verify</b></a>
<pre>
 public native void verify(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                           byte buf[],
                           int cyl,
                           int head,
                           int cylExpected,
                           int headExpected,
                           int sector,
                           int sectorLen) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Verify a disc sector whose numbering may not match its disc location.
 Not all drivers implement this function; those that don't will throw
 a DskException with error DSK_ERR_NOTIMPL.
 <p>Unless you are emulating a floppy controller, you should not need to 
 use this call.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The data to be compared with what's on disc.
    <dd> cyl - The physical cylinder containing the sector.
    <dd> head - The physical head to use.
    <dd> cylExpected - The expected cylinder number in the sector header.
    <dd> cylExpected - The expected head number in the sector header.
    <dd> sector - The number of the sector.
    <dd> sectorLen - The number of bytes to transfer (may be less than a
                 full sector).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason; DSK_ERR_MISMATCH
                     if the data read don't match the buffer.
  </dl></dd>
</dl>
<a name="format(uk.co.demon.seasip.libdsk.Geometry, int, int, uk.co.demon.seasip.libdsk.FormatData[], byte)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="format"><b>format</b></a>
<pre>
 public native void format(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                           int cyl,
                           int h,
                           <a href="uk.co.demon.seasip.libdsk.FormatData.html#_top_">FormatData</a> fd[],
                           byte filler) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Format a track, using physical cylinder/sector.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> c - The physical cylinder to use.
    <dd> h - The physical head to use.
    <dd> fd - An array of FormatData objects containing sector headers.
    <dd> filler - The byte with which to fill the empty sectors.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the format failed for any reason, or the driver cannot
                     format tracks.
  </dl></dd>
</dl>
<a name="format(uk.co.demon.seasip.libdsk.Geometry, int, uk.co.demon.seasip.libdsk.FormatData[], byte)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="format"><b>format</b></a>
<pre>
 public native void format(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                           int track,
                           <a href="uk.co.demon.seasip.libdsk.FormatData.html#_top_">FormatData</a> fd[],
                           byte filler) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Format a track, generating the sector headers automatically.
 The resulting track headers will be correct for standard DOS, PCW or 
 Linux floppies.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> track - The logical track to format.
    <dd> fd - An array of FormatData objects containing sector headers.
    <dd> filler - The byte with which to fill the empty sectors.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the format failed for any reason, or the driver cannot
                     format tracks.
  </dl></dd>
</dl>
<a name="readTrack(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="readTrack"><b>readTrack</b></a>
<pre>
 public native void readTrack(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                              byte buf[],
                              int cylinder,
                              int head) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a track using a physical head/cylinder number.
 This will use the FDC's READ TRACK command if it is available; otherwise
 it will just do repeated sector reads.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The buffer to be filled with data.
    <dd> cyl - The physical cylinder to use.
    <dd> head - The physical head to use.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason, or the driver cannot
                     read sectors.
  </dl></dd>
</dl>
<a name="readTrack(uk.co.demon.seasip.libdsk.Geometry, byte[], int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="readTrack"><b>readTrack</b></a>
<pre>
 public native void readTrack(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                              byte buf[],
                              int track) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a track using a logical track number.
 This will use the FDC's READ TRACK command if it is available; otherwise
 it will just do repeated sector reads.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use. This will be used to translate the
         track number to a physical cylinder/head.
    <dd> buf - The buffer to be filled with data.
    <dd> track - The number of the track (0 is the first track).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason, or the driver cannot
                     read sectors.
  </dl></dd>
</dl>
<a name="readTrack(uk.co.demon.seasip.libdsk.Geometry, byte[], int, int, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="readTrack"><b>readTrack</b></a>
<pre>
 public native void readTrack(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                              byte buf[],
                              int cylinder,
                              int head,
                              int cylExpected,
                              int headExpected) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a track whose sector headers may not match its location.
 This will use the FDC's READ TRACK command if it is available; otherwise
 it will just do repeated sector reads.
 <p>Not all drivers implement this function; those that don't will throw
 a DskException with error DSK_ERR_NOTIMPL.
 <p>Unless you are emulating a floppy controller, you should not need to 
 use this call.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> buf - The buffer to be filled with data.
    <dd> cyl - The physical cylinder to use.
    <dd> head - The physical head to use.
    <dd> cylExpected - The expected cylinder number in the sector header.
    <dd> cylExpected - The expected head number in the sector header.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the read failed for any reason, or the driver cannot
                     read sectors.
  </dl></dd>
</dl>
<a name="autoFormat(uk.co.demon.seasip.libdsk.Geometry, int, int, byte)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="autoFormat"><b>autoFormat</b></a>
<pre>
 public native void autoFormat(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                               int cylinder,
                               int head,
                               byte filler) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Format a track, generating the sector headers automatically.
 The resulting track headers will be correct for standard DOS, PCW or 
 Linux floppies.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> cyl - The physical cylinder to use.
    <dd> head - The physical head to use.
    <dd> filler - The byte with which to fill the empty sectors.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the format failed for any reason, or the driver cannot
                     format tracks.
  </dl></dd>
</dl>
<a name="autoFormat(uk.co.demon.seasip.libdsk.Geometry, int, byte)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="autoFormat"><b>autoFormat</b></a>
<pre>
 public native void autoFormat(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                               int track,
                               byte filler) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Format a track, generating the sector headers automatically.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> track - The logical track number to format.
    <dd> filler - The byte with which to fill the empty sectors.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the format failed for any reason, or the driver cannot
                     format tracks.
  </dl></dd>
</dl>
<a name="probeGeometry(uk.co.demon.seasip.libdsk.Geometry)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="probeGeometry"><b>probeGeometry</b></a>
<pre>
 public native void probeGeometry(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Probe the geometry of a disc. This will use the boot sector and any
 information the driver can give.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - A newly-created Geometry object. This will be populated on
         return.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> DSK_ERR_BADFMT if the format can't be detected;
                     other values if there's a read error.
  </dl></dd>
</dl>
<a name="sectorID(uk.co.demon.seasip.libdsk.Geometry, int, uk.co.demon.seasip.libdsk.FormatData)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="sectorID"><b>sectorID</b></a>
<pre>
 public native void sectorID(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                             int track,
                             <a href="uk.co.demon.seasip.libdsk.FormatData.html#_top_">FormatData</a> result) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a random sector ID. This can be used to probe for discs
 with oddly-numbered sectors (eg, numbered 65-74).
<p>Note that the Win32c driver implements a limited version of this call,
 which will work on normal DOS / CP/M86 / PCW discs and CPC discs. However
 it will not be usable for other purposes.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The geometry for the drive.
    <dd> track - The logical track on which to look for sectors.
    <dd> result - A new FormatData object which will be populated with the
              sector header that was found.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> if the driver does not provide this functionality
              or no sector was found.
  </dl></dd>
</dl>
<a name="sectorID(uk.co.demon.seasip.libdsk.Geometry, int, int, uk.co.demon.seasip.libdsk.FormatData)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="sectorID"><b>sectorID</b></a>
<pre>
 public native void sectorID(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                             int cyl,
                             int head,
                             <a href="uk.co.demon.seasip.libdsk.FormatData.html#_top_">FormatData</a> result) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Read a random sector ID. This can be used to probe for discs
 with oddly-numbered sectors (eg, numbered 65-74).
<p>Note that the Win32c driver implements a limited version of this call,
 which will work on normal DOS / CP/M86 / PCW discs and CPC discs. However
 it will not be usable for other purposes.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The geometry for the drive.
    <dd> cyl - The physical cylinder on which to look for sectors.
    <dd> head - The physical head on which to look for sectors.
    <dd> result - A new FormatData object which will be populated with the
              sector header that was found.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> if the driver does not provide this functionality
              or no sector was found.
  </dl></dd>
</dl>
<a name="seek(uk.co.demon.seasip.libdsk.Geometry, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="seek"><b>seek</b></a>
<pre>
 public native void seek(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                         int track) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Seek to a track using a logical track number.
 Unless you are emulating a floppy controller, you should not need to 
 use this call.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use. This will be used to translate the
         track number to a physical cylinder/head.
    <dd> track - The number of the track (0 is the first track).
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the seek failed; DSK_ERR_NOTIMPL if the
               underlying driver doesn't support this.
  </dl></dd>
</dl>
<a name="seek(uk.co.demon.seasip.libdsk.Geometry, int, int)"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="seek"><b>seek</b></a>
<pre>
 public native void seek(<a href="uk.co.demon.seasip.libdsk.Geometry.html#_top_">Geometry</a> g,
                         int cyl,
                         int head) throws <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
</pre>
<dl>
  <dd> Seek to a track using a physical cylinder/head number.
 Unless you are emulating a floppy controller, you should not need to 
 use this call.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> g - The drive geometry to use.
    <dd> cyl - The cylinder to seek to.
    <dd> head - The head to use.
    <dt> <b>Throws:</b> <a href="uk.co.demon.seasip.libdsk.DskException.html#_top_">DskException</a>
    <dd> If the seek failed; DSK_ERR_NOTIMPL if the
               underlying driver doesn't support this.
  </dl></dd>
</dl>
<a name="enumDrivers(int)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="enumDrivers"><b>enumDrivers</b></a>
<pre>
 public static native String enumDrivers(int index)
</pre>
<dl>
  <dd> Get the name of a built-in driver.
<p>
  <dd><dl>
    <dt> <b>Parameters:</b>
    <dd> index - If the index is in range, return the n'th driver name.
    <dt> <b>Returns:</b>
    <dd> The driver name; null if index is out of range.
  </dl></dd>
</dl>
<a name="getDriverName()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getDriverName"><b>getDriverName</b></a>
<pre>
 public native String getDriverName()
</pre>
<dl>
  <dd> Get the name of the driver being used for this drive. 
 for example: "dsk".
<p>
</dl>
<a name="getDriverDesc()"><img src="images/red-ball.gif" width=12 height=12 alt=" o "></a>
<a name="getDriverDesc"><b>getDriverDesc</b></a>
<pre>
 public native String getDriverDesc()
</pre>
<dl>
  <dd> Get the description of the driver being used for this drive. 
 for example: "CPCEMU .DSK driver"
<p>
</dl>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-uk.co.demon.seasip.libdsk.html">This Package</a>  <a href="Package-uk.co.demon.seasip.libdsk.html">Previous</a>  <a href="uk.co.demon.seasip.libdsk.FormatData.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
