#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-1
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
LibDsk v1.5.9-pre
\end_layout

\begin_layout Author
John Elliott
\end_layout

\begin_layout Abstract
LibDsk is a library intended to give transparent access to floppy drives
 and to the 
\begin_inset Quotes eld
\end_inset

disc image files
\begin_inset Quotes erd
\end_inset

 used by emulators to represent floppy drives.
\end_layout

\begin_layout Abstract
This library is free software, released under the GNU Library GPL.
 See COPYING for details.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
About this document
\end_layout

\begin_layout Standard
This document only covers LibDsk -- the library -- itself.
 For information on the example utilities supplied with LibDsk (apriboot,
 dskform, dsktrans, dskid, dskdump, dskscan, dskutil and md3serial) see
 their respective manual pages.
\end_layout

\begin_layout Subsection
About LibDsk
\end_layout

\begin_layout Standard
LibDsk is a library for accessing floppy drives and disc images transparently.
 It currently supports the following disc image formats:
\end_layout

\begin_layout Itemize
Raw 
\begin_inset Quotes eld
\end_inset

dd if=foo of=bar
\begin_inset Quotes erd
\end_inset

 images;
\end_layout

\begin_layout Itemize
Raw images in logical filesystem order;
\end_layout

\begin_layout Itemize
CPCEMU-format .DSK images (normal and extended); 
\end_layout

\begin_layout Itemize
MYZ80-format hard drive images; 
\end_layout

\begin_layout Itemize
CFI-format disc images, as produced by FDCOPY.COM under DOS and used to distribut
e some Amstrad system discs; 
\end_layout

\begin_layout Itemize
ApriDisk-format disc images, used by the utility of the same name under
 DOS.
\end_layout

\begin_layout Itemize
NanoWasp-format disc images, used by the eponymous emulator.
\end_layout

\begin_layout Itemize
IMD-format disc images, as produced by Dave Dunfield's ImageDisk utility.
\end_layout

\begin_layout Itemize
Yaze 'ydsk' disc images, created by the 'yaze' and 'yaze-ag' emulators.
\end_layout

\begin_layout Itemize
JV3-format disc images, used in TRS-80 emulation.
\end_layout

\begin_layout Itemize
Compaq Quick Release Sector Transfer (QRST), used for their computers' BIOS
 setup floppies.
\end_layout

\begin_layout Itemize
Disc images created by the Sydex imaging programs Teledisk and CopyQM (Not
 supported in the 16-bit Windows version).
\end_layout

\begin_layout Itemize
SAP disc images used in emulation of Thomson computers.
\end_layout

\begin_layout Itemize
The floppy drive under Linux; 
\end_layout

\begin_layout Itemize
The floppy drive under Windows.
 Windows support is a complicated subject - see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "ldwindows"

\end_inset

 below.
\end_layout

\begin_layout Itemize
The floppy drive (and hard drive partitions) under DOS.
\end_layout

\begin_layout Itemize
LDBS: A disc image format still under development.
 See LDBS/ldbs.html for more information.
\end_layout

\begin_layout Standard
LibDsk also supports compressed disc images in the following formats: 
\end_layout

\begin_layout Itemize
Squeeze (Huffman coded) 
\end_layout

\begin_layout Itemize
GZip (Deflate ) 
\end_layout

\begin_layout Itemize
BZip2 (Burrows-Wheeler; support is read-only)
\end_layout

\begin_layout Itemize
TeleDisk 'advanced' compression (LZH; support is read-only, and confined
 to TeleDisk disk images)
\end_layout

\begin_layout Subsection
What's new? 
\end_layout

\begin_layout Standard

\series bold
Important note: 
\series default
If you have coded against a version of LibDsk prior to 1.5.3, bear in mind
 that 1.5.3 is a substantial rewrite.
 The API for your programs remains the same, but there are differences in
 implementation that may trip you up.
 In particular, if you are writing to a disc image file it is very important
 to check the result of dsk_close() -- there are a lot of drivers which
 make their changes in memory and don't try to commit them until dsk_close()
 is called.
\end_layout

\begin_layout Standard
For full details, see the file ChangeLog.
\end_layout

\begin_layout Itemize
dskform can now format disc images with a blank PCDOS or Apricot MSDOS filesyste
m.
\end_layout

\begin_layout Itemize
Added a new 'sap' driver for SAP-format disc images (thanks to Emulix75
 for information).
\end_layout

\begin_layout Itemize
When converting to Teledisk TD0 format, attempt to come up with a plausible
 value for the drive type (3.5
\begin_inset Quotes erd
\end_inset

 / 5.25
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Itemize
The geometry probe has been amended to try and get the correct data rate
 on disc images that don't include this information as metadata.
\end_layout

\begin_layout Itemize
The 'dsk' / 'edsk' driver has been rewritten to support the extensions described
 at <http://simonowen.com/misc/extextdsk.txt>
\end_layout

\begin_layout Itemize
The LDBS file format has been changed to support the above extensions.
 LDBS files created by LibDsk 1.5.3 and earlier can still be used, but don't
 support the extensions.
\end_layout

\begin_layout Itemize
Added a new 'qrst' driver for Compaq QRST-format disc images.
\end_layout

\begin_layout Itemize
Various bugfixes in the IMD driver.
\end_layout

\begin_layout Itemize
Added a new 'ldbs' driver for LDBS-format disc images.
 
\end_layout

\begin_layout Itemize
CopyQM and Teledisk are no longer supported in 16-bit Windows builds, because
 16-bit Windows does not provide the sscanf() function to DLLs.
\end_layout

\begin_layout Itemize
Added a new 'complement' option to the drive geometry, allowing for disc
 image formats where the bytes are stored complemented.
\end_layout

\begin_layout Itemize
Added a new 'jv3' driver for JV3-format disc images.
\end_layout

\begin_layout Itemize
A bugfix to the automatic geometry probe in the 'imd' driver: HD discs were
 not being correctly detected.
\end_layout

\begin_layout Itemize
Added a new 'imd' driver for IMD-format disc images.
\end_layout

\begin_layout Itemize
A new SIDES_EXTSURFACE geometry, for disc images where the sector numbers
 on side 1 follow on from side 0.
\end_layout

\begin_layout Itemize
TeleDisk images with 'advanced' (LZH) compression are now supported.
\end_layout

\begin_layout Itemize
Added a new 'ydsk' driver for YAZE ydsk-format disc images.
\end_layout

\begin_layout Itemize
Some disc image files include filesystem information as part of the disc
 image metadata.
 dskid and dsktrans now display and copy this information.
\end_layout

\begin_layout Itemize
Should now compile out of the box on FreeBSD.
\end_layout

\begin_layout Itemize
A bugfix to the rcpmfs driver should allow it to simulate a CP/M 2 filesystem
 as well as CP/M 3.
\end_layout

\begin_layout Subsection
Terms and definitions
\end_layout

\begin_layout Standard
In this document, I use the word 
\noun on
cylinder
\noun toggle
 to refer to a position on a floppy disc, and 
\noun on
track
\noun toggle
 to refer to the data within a cylinder on one side of the disc.
 For a single-sided disc, these are the same; for a double-sided disc, there
 are twice as many tracks as cylinders.
 
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "formats"

\end_inset

Supported file formats
\end_layout

\begin_layout Standard
The following disc image file formats are supported by LibDsk.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

dsk
\begin_inset Quotes erd
\end_inset

 : Disc image in the DSK format used by CPCEMU.
 The format of a .DSK file is described in the CPCEMU documentation.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

edsk
\begin_inset Quotes erd
\end_inset

 : Disc image in the extended CPCEMU DSK format.
 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 : Raw disc image - as produced by 
\begin_inset Quotes eld
\end_inset


\family typewriter
dd if=/dev/fd0 of=image
\family default

\begin_inset Quotes erd
\end_inset

.
 On systems other than Linux, DOS or Windows, this is also used to access
 the host system's floppy drive.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

rawoo
\begin_inset Quotes erd
\end_inset

 : Raw disc image, ordered so that all the tracks on side 0 come first,
 then all the tracks on side 1.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

rawob
\begin_inset Quotes erd
\end_inset

 : Raw disc image, ordered so that all the tracks on side 0 come first,
 then all the tracks on side 1 in reverse order.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

logical
\begin_inset Quotes erd
\end_inset

 : Raw disc image in logical filesystem order.
 Early versions of LibDsk could generate such images (for example, by using
 the now-deprecated 
\family typewriter
-logical
\family default
 option to dsktrans) but couldn't then write them back or use them in emulators.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

floppy
\begin_inset Quotes erd
\end_inset

 : Host system's floppy drive (under Linux, DOS or Windows).
 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

int25
\begin_inset Quotes erd
\end_inset

 : Hard drive partition under DOS.
 Also used for the floppy drive on Apricot PCs.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

ntwdm
\begin_inset Quotes erd
\end_inset

 : Enhanced floppy support under Windows 2000 and XP, using an additional
 kernel-mode driver.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

myz80
\begin_inset Quotes erd
\end_inset

 : MYZ80 hard drive image, which is 
\emph on
nearly
\emph default
 
\emph toggle
the same as 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 but has a 256 byte header.
 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

cfi
\begin_inset Quotes erd
\end_inset

 : Compressed floppy image, as produced by FDCOPY.COM under DOS.
 Its format is described in cfi.html.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

imd
\begin_inset Quotes erd
\end_inset

 : Disc images created by Dave Dunfield's ImageDisk utility.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

jv3
\begin_inset Quotes erd
\end_inset

 : Disc images used by Jeff Vavasour's TRS-80 emulators.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

qm
\begin_inset Quotes erd
\end_inset

 : Disc images created by Sydex's CopyQM.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

tele
\begin_inset Quotes erd
\end_inset

 : Disc images created by Sydex's TeleDisk.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

nanowasp
\begin_inset Quotes erd
\end_inset

 : Disc image in the 400k Microbee format used by the NanoWasp emulator.
 This is similar to 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

, but the tracks are stored in a different order.
 LibDsk also applies a sector skew so that the sectors are read/written
 in the logical order.
 Strictly speaking, it should not do this (when libdsk is used with cpmtools,
 cpmtools is the one that does the skewing) but cpmtools cannot handle the
 skewing scheme used by the Microbee format.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

apridisk
\begin_inset Quotes erd
\end_inset

: Disc image in the format used by the ApriDisk utility.
 The format is described in apridisk.html.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

rcpmfs
\begin_inset Quotes erd
\end_inset

: Reverse CP/M filesystem.
 A directory is made to appear as a CP/M disk.
 This is a complex system and should be approached with caution.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

remote
\begin_inset Quotes erd
\end_inset

: Remote LibDsk server, most likely at the other end of a serial line.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

ydsk
\begin_inset Quotes erd
\end_inset

: Disc image format used by the yaze and yaze-ag CP/M emulators.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

qrst
\begin_inset Quotes erd
\end_inset

: Compaq Quick Release Sector Transfer.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

ldbs
\begin_inset Quotes erd
\end_inset

: LibDsk Block Store.
\end_layout

\begin_layout Section
Architecture 
\end_layout

\begin_layout Standard
LibDsk is composed of a fixed core (files named 
\family typewriter
dsk*.c
\family default
) and a number of drivers (files named 
\family typewriter
drv*.c
\family default
).
 When you open an image or a drive (using 
\family typewriter
dsk_open()
\family default
 or 
\family typewriter
dsk_creat()
\family default
 ) then a driver is chosen.
 This driver is then used until it's closed (
\family typewriter
dsk_close()
\family default
).
 
\end_layout

\begin_layout Standard
Each driver is identified by a name.
 To get a list of available drivers, use 
\family typewriter
dsk_type_enum()
\family default
.
 To get the driver that is being used by an open DSK image, use 
\family typewriter
dsk_drvname()
\family default
 or 
\family typewriter
dsk_drvdesc()
\family default
.
\end_layout

\begin_layout Subsection
Logical and physical sectors
\end_layout

\begin_layout Standard
LibDsk has two models of disc geometry.
 One is as a linear array of 
\begin_inset Quotes eld
\end_inset

logical
\begin_inset Quotes erd
\end_inset

 sectors - for example, a 720k floppy appears as 1440 512-byte sectors numbered
 0 to 1439.
 The other locates each sector using a (Cylinder, Head, Sector) triple -
 so on the 720k floppy described earlier, sectors would run from (0,0,1)
 to (79,1,9).
 
\end_layout

\begin_layout Standard
Internally, all LibDsk drivers are written to use the Cylinder/Head/Sector
 model.
 For those calls which take parameters in logical sectors, LibDsk uses the
 information in a 
\family typewriter
DSK_GEOMETRY
\family default
 structure to convert to C/H/S.
 
\family typewriter
DSK_GEOMETRY
\family default
 also contains information such as the sector size and data rate used to
 access a given disc.
 
\end_layout

\begin_layout Standard
Those functions which deal with whole tracks (such as the command to format
 a track) use logical tracks and (cylinder,head) pairs instead.
 To initialise a 
\family typewriter
DSK_GEOMETRY
\family default
 structure, either: 
\end_layout

\begin_layout Itemize
call 
\family typewriter
dsk_getgeom()
\family default
 to try and detect it from the disc; or 
\end_layout

\begin_layout Itemize
call 
\family typewriter
dg_stdformat()
\family default
 to select one of the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 formats that LibDsk knows about; or 
\end_layout

\begin_layout Itemize
call 
\family typewriter
dg_dosgeom()
\family default
 / 
\family typewriter
dg_cpm86geom()
\family default
 / 
\family typewriter
dg_pcwgeom()
\family default
 / 
\family typewriter
dg_aprigeom()
\family default
 to initialise it from a copy of a DOS / CP/M86 / PCW / Apricot boot sector;
 or 
\end_layout

\begin_layout Itemize
Set all the members manually.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sec: dskgeom"

\end_inset

DSK_GEOMETRY in detail
\end_layout

\begin_layout LyX-Code
typedef struct
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout Description

\family typewriter
dsk_sides_t
\begin_inset space ~
\end_inset

dg_sidedness;
\family default
 /* This describes the logical sequence of tracks on the disc - the order
 in which their host system reads them.
 This will only be used if 
\family typewriter
dg_heads
\family default
 is greater than 1 (otherwise all the methods are equivalent) and you are
 using functions that take logical sectors or tracks as parameters.
 It will be one of: 
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
SIDES_ALT
\family default
 The tracks are ordered Cylinder 0 Head 0; C0H1; C1H0; C1H1; C2H0; C2H1
 etc.
 This layout is used by most PC-hosted operating systems, including DOS
 and Linux.
 Amstrad's 8-bit operating systems also use this ordering.
\end_layout

\begin_layout Description

\family typewriter
SIDES_OUTBACK
\family default
 The tracks go out to the edge on Head 0, and then back in on Head 1 (so
 Cylinder 0 Head 0 is the first track, while Cylinder 0 Head 1 is the last).
 This layout is used by Freek Heite's 144FEAT driver (for CP/M-86 on the
 PC) but I have not seen it elsewhere.
\end_layout

\begin_layout Description

\family typewriter
SIDES_OUTOUT
\family default
 The tracks go out to the edge on Head 0, then out again on Head 1 (so the
 order goes C(last)H0, C0H1, C1H1, ..., C(last)H1).
 This ordering is used by Acorn-format discs.
\end_layout

\begin_layout Description

\family typewriter
SIDES_EXTSURFACE
\family default
 The tracks are arranged in the same way as SIDES_ALT, but if the sectors
 on side 0 are numbered 1-
\emph on
n
\emph default
, the sectors on side 1 are numbered 
\emph on
n
\emph default
+1 - 2*
\emph on
n
\emph default
 (for example, side 0 are numbered 1-9, and side 1 are numbered 10-18).
 This is a new option and should be treated with caution!
\end_layout

\begin_layout Standard
*/
\end_layout

\end_deeper
\begin_layout Description

\family typewriter
dsk_pcyl_t
\begin_inset space ~
\end_inset

dg_cylinders;
\family default
 /* The number of cylinders this disc has.
 Usually 40 or 80.
 */
\end_layout

\begin_layout Description

\family typewriter
dsk_phead_t
\begin_inset space ~
\end_inset

dg_heads;
\family default
 /* The number of heads (sides) the disc has.
 Usually 1 or 2.
 */
\end_layout

\begin_layout Description

\family typewriter
dsk_psect_t
\begin_inset space ~
\end_inset

dg_sectors;
\family default
 /* The number of sectors per track.
 */
\end_layout

\begin_layout Description

\family typewriter
dsk_psect_t
\begin_inset space ~
\end_inset

dg_secbase;
\family default
 /* The first physical sector number.
 Most systems start numbering their sectors at 1; Acorn systems start at
 0, and Amstrad CPCs start at 65 or 193.
 */
\end_layout

\begin_layout Description

\family typewriter
size_t
\begin_inset space ~
\end_inset

dg_secsize;
\family default
 /* Sector size in bytes.
 Note that several drivers rely on this being a power of 2.
 */
\end_layout

\begin_layout Description

\family typewriter
dsk_rate_t
\begin_inset space ~
\end_inset

dg_datarate;
\family default
 /* Data rate.
 This will be one of:
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
RATE_HD
\family default
 High-density disc (1.4Mb or 1.2Mb)
\end_layout

\begin_layout Description

\family typewriter
RATE_DD
\family default
 Double-density disc in 1.2Mb drive (ie, 360k disc in 1.2Mb drive)
\end_layout

\begin_layout Description

\family typewriter
RATE_SD
\family default
 Double-density disc in 1.4Mb or 720k drive
\end_layout

\begin_layout Description

\family typewriter
RATE_ED
\family default
 Extra-density disc (2.8Mb) */
\end_layout

\end_deeper
\begin_layout Description

\family typewriter
dsk_gap_t
\begin_inset space ~
\end_inset

dg_rwgap;
\family default
 /* Read/write gap length */
\end_layout

\begin_layout Description

\family typewriter
dsk_gap_t
\begin_inset space ~
\end_inset

dg_fmtgap;
\family default
 /* Format gap length */
\end_layout

\begin_layout Description

\family typewriter
int
\begin_inset space ~
\end_inset

dg_fm;
\family default
 /* This is really a dsk_recmode_t, but is declared as an int for backward
 compatibility.
 It contains the recording mode and additional flags.
 To extract the recording mode, use (dg_fm & RECMODE_MASK):
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
RECMODE_MFM
\family default
 MFM (double density) recording mode.
\end_layout

\begin_layout Description

\family typewriter
RECMODE_FM
\family default
 FM (single density) recording mode.
 Not all PC floppy controllers support this mode; the National Semiconductor
 PC87306 and the Future Domain TMC series SCSI controllers can at least
 read FM discs.
 The BBC Micro used FM recording for its 100k and 200k DFS formats.
 The Windows / DOS floppy drivers do not support FM recording.
 
\end_layout

\begin_layout Standard
To extract the flags, use (dg_fm & RECMODE_FLAGMASK).
 There is currently one additional flag: 
\series bold
RECMODE_COMPLEMENT
\series default
.
 If this flag is set, bytes written on the disc are stored complemented
 (ie, XORed with 0xFF).
 */
\end_layout

\end_deeper
\begin_layout Description

\family typewriter
int
\begin_inset space ~
\end_inset

dg_nomulti;
\family default
 /* Set to nonzero to disable multitrack mode.
 This only affects attempts to read normal data from tracks containing deleted
 data (or vice versa).
 */
\end_layout

\begin_layout Description

\family typewriter
int
\begin_inset space ~
\end_inset

dg_noskip;
\family default
 /* Set to nonzero to disable skipping deleted data when searching for non-delet
ed data (or vice versa).
 */
\end_layout

\begin_layout LyX-Code
} DSK_GEOMETRY;
\end_layout

\begin_layout Section
LibDsk Function Reference 
\end_layout

\begin_layout Subsection
dsk_open: Open an existing disc image
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_open(DSK_PDRIVER *self, const char *filename, const char *type,
 const char *compress)
\end_layout

\begin_layout Standard
Enter with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 is the address of a DSK_PDRIVER variable (treat it as a handle to a drive
 / disc file).
 On return, the variable will be non-null (if the operation succeeded) or
 null (if the operation failed).
  
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 is the name of the disc image file.
 On DOS and Windows, 
\begin_inset Quotes eld
\end_inset

A:
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

B:
\begin_inset Quotes erd
\end_inset

 refer to the two floppy drives.
 On Apricot MS-DOS, 
\begin_inset Quotes eld
\end_inset

0:
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

1:
\begin_inset Quotes erd
\end_inset

 refer to the floppy drives.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 is NULL to detect the disc image format automatically, or the name of a
 LibDsk driver to force that driver to be used.
 See 
\family typewriter
dsk_type_enum()
\family default
 below.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

compress
\begin_inset Quotes erd
\end_inset

 is NULL to auto-detect compressed files, or the name of a LibDsk compression
 scheme.
 See 
\family typewriter
dsk_comp_enum()
\family default
.
 
\end_layout

\begin_layout Standard
Returns: A 
\family typewriter
dsk_err_t,
\family default
 which will be 0 (
\family typewriter
DSK_ERR_OK
\family default
) if successful, or a negative integer if failed.
 See 
\family typewriter
dsk_strerror()
\family default
.
 The error 
\family typewriter
DSK_ERR_NOTME
\family default
 means either that no driver was able to open the disc / disc image (if
 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 was NULL) or that the requested driver could not open the file (if 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 was not NULL).
\end_layout

\begin_layout Standard
Standard LibDsk drivers are listed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "formats"

\end_inset

.
\end_layout

\begin_layout Standard
Compression schemes are: 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

sq
\begin_inset Quotes erd
\end_inset

 : Huffman (squeezed).
 The reason for the inclusion of this system is to support .DQK images (see
 appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec: dqk"

\end_inset

).
 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

gz
\begin_inset Quotes erd
\end_inset

 : GZip (deflate).
 This will only be present if libdsk was built with zlib support.
 
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

bz2
\begin_inset Quotes erd
\end_inset

 : BZip2 (Burrows-Wheeler compression).
 This support is currently read-only, and will only be present if LibDsk
 was built with bzlib support.
\end_layout

\begin_layout Subsection
dsk_creat: Create a new disc image
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_creat(DSK_PDRIVER *self, const char *filename, const char
 *type)
\end_layout

\begin_layout Standard
In the case of floppy drives, this acts exactly as 
\family typewriter
dsk_open()
\family default
.
 For image files, the file will be deleted and recreated.
 Parameters and results are as for 
\family typewriter
dsk_open()
\family default
, except that 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 cannot be NULL (it must specify the type of disc image to be created) and
 if 
\begin_inset Quotes eld
\end_inset

compress
\begin_inset Quotes erd
\end_inset

 is NULL, it means that the file being created should not be compressed.
\end_layout

\begin_layout Subsection
dsk_close: Close a drive or disc image
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_close(DSK_PDRIVER *self)
\end_layout

\begin_layout Standard
Pass the address of an opaque pointer returned from 
\family typewriter
dsk_open()
\family default
 / 
\family typewriter
dsk_creat()
\family default
.
 On return, the drive will have been closed and the pointer set to NULL.
 It is important to check the result of this function; many drivers don't
 write their changes back until dsk_close() is called.
\end_layout

\begin_layout Subsection
dsk_dirty: Read the dirty flag
\end_layout

\begin_layout LyX-Code
int dsk_dirty(DSK_PDRIVER self)
\end_layout

\begin_layout Standard
This function returns non-zero if the disc has been modified since it was
 inserted into the drive, and zero if it has not been modified.
 
\end_layout

\begin_layout Subsection
dsk_pread, dsk_lread : Read a sector
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_pread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, dsk_psect_t sector) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_lread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_lsect_t sector)
\end_layout

\begin_layout Standard
These functions read a single sector from the disc.
 There are two of them, depending on whether you are using logical or physical
 sector addresses.
\end_layout

\begin_layout Standard
Enter with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 is a handle to an open drive / image file.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

geom
\begin_inset Quotes erd
\end_inset

 points to the geometry for the drive.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

buf
\begin_inset Quotes erd
\end_inset

 is the buffer into which data will be loaded.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

cylinder
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

sector
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_pread
\family default
) or 
\begin_inset Quotes eld
\end_inset

sector
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_lread
\family default
) give the location of the sector.
 
\end_layout

\begin_layout Standard
Returns: 
\end_layout

\begin_layout Itemize
If successful, DSK_ERR_OK.
 Otherwise, a negative DSK_ERR_* value.
 
\end_layout

\begin_layout Itemize
If the driver cannot read sectors, DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Subsection
dsk_pwrite, dsk_lwrite: Write a sector
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_pwrite(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const void
 *buf, dsk_pcyl_t cylinder, dsk_phead_t head, dsk_psect_t sector) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_lwrite(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const void
 *buf, dsk_lsect_t sector)
\end_layout

\begin_layout Standard
As dsk_pread / dsk_lread, but write their buffers to disc rather than reading
 them from disc.
 If the driver cannot write sectors, DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Subsection
dsk_pcheck, dsk_lcheck: Verify sectors on disc against memory
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_pcheck(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const void
 *buf, dsk_pcyl_t cylinder, dsk_phead_t head, dsk_psect_t sector) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_lcheck(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const void
 *buf, dsk_lsect_t sector)
\end_layout

\begin_layout Standard
As 
\family typewriter
dsk_pread
\family default
 / 
\family typewriter
dsk_lread
\family default
, but rather than reading their buffers from disc, they compare the contents
 of their buffers with the data already on the disc.
 If the data match, the functions return DSK_ERR_OK.
 If there is a mismatch, they return DSK_ERR_MISMATCH.
 In case of error, other DSK_ERR_* values are returned.
 If the driver cannot read sectors, DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Subsection
dsk_pformat, dsk_lformat: Format a disc track
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_pformat(DSK_PDRIVER self, DSK_GEOMETRY *geom, dsk_pcyl_t cylinder,
 dsk_phead_t head, const DSK_FORMAT *format, unsigned char filler) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_lformat(DSK_PDRIVER self, DSK_GEOMETRY *geom, dsk_ltrack_t
 track, const DSK_FORMAT *format, unsigned char filler)
\end_layout

\begin_layout Standard
Enter with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 is a handle to an open drive / image file.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

geom
\begin_inset Quotes erd
\end_inset

 points to the geometry for the drive.
 The formatter may modify this if (for example) it's asked to format track
 41 of a 40-track drive.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

cylinder
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_pformat
\family default
) or 
\begin_inset Quotes eld
\end_inset

track
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_lformat
\family default
) give the location of the track to format.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

format
\begin_inset Quotes erd
\end_inset

 should be an array of (
\family typewriter
geom->dg_sectors
\family default
) DSK_FORMAT structures.
 These structures must contain sector headers for the track being formatted.
 For example, to format the first track of a 720k disc, you would pass in
 an array of 9 such structures: { 0, 0, 1, 512 }, { 0, 0, 2, 512, } ..., {
 0, 0, 9, 512 } 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

filler
\begin_inset Quotes erd
\end_inset

 should be the filler byte to use.
 Currently the Win32 driver ignores this parameter.
 If the driver cannot format tracks, DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Standard
Note that when formatting a .DSK file that has more than one head, you must
 format cylinder 0 for each head before formatting other cylinders.
\end_layout

\begin_layout Subsection
dsk_apform, dsk_alform: Automatic format
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_apform(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head, unsigned char filler) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_alform(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_ltrack_t
 track, unsigned char filler)
\end_layout

\begin_layout Standard
These function calls behave as 
\family typewriter
dsk_pformat()
\family default
 and 
\family typewriter
dsk_lformat()
\family default
 above, except that the sector headers are automatically generated.
 This saves time and trouble setting up sector headers on discs with standard
 layouts such as DOS, PCW or Linux floppies.
 If the driver cannot format tracks, DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Subsection
dsk_psecid, dsk_lsecid: Read a sector ID.
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_psecid(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head, DSK_FORMAT *result) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_lsecid(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_ltrack_t
 track, DSK_FORMAT *result)
\end_layout

\begin_layout Standard
Read a sector ID from the given track.
 This can be used to probe for discs with oddly-numbered sectors (eg, numbered
 65-74).
 Enter with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 is a handle to an open drive / image file.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

geom
\begin_inset Quotes erd
\end_inset

 points to the geometry for the drive.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

cylinder
\begin_inset Quotes erd
\end_inset

 / 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_psecid
\family default
) or 
\begin_inset Quotes eld
\end_inset

track
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_lsecid
\family default
) give the location of the track to read the sector from.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

 points to an uninitialised 
\family typewriter
DSK_FORMAT
\family default
 structure.
 
\end_layout

\begin_layout Standard
On return: 
\end_layout

\begin_layout Itemize
If successful, the buffer at 
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

 will be initialised with the sector header found, and DSK_ERR_OK will be
 returned.
 
\end_layout

\begin_layout Itemize
If the driver cannot provide this functionality (for example, the Win32
 driver under NT), DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Standard
Note that the DOS, Win16 and Win32 (under Win9x) drivers implement a limited
 version of this call, which will work on normal DOS / CP/M86 / PCW discs
 and CPC discs.
 However it will not be usable for other purposes.
\end_layout

\begin_layout Subsection
dsk_ptrackids, dsk_ltrackids: Identify sectors on track.
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_ptrackids(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head, dsk_psect_t *count, DSK_FORMAT **result) 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_ltrackids(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_ltrack_t
 track, dsk_psect_t *count, DSK_FORMAT **result)
\end_layout

\begin_layout Standard
These functions are intended to read all the sector IDs from a track, in
 order, and (preferably) starting at the index hole.
 If they succeed, 'result' will point at an array of DSK_FORMAT structures
 describing the sectors found.
 This array will have been allocated with dsk_malloc() and should be freed
 with dsk_free().
\end_layout

\begin_layout Subsection
dsk_rtread: Reserved.
\end_layout

\begin_layout LyX-Code
dsk_err_t  dsk_rtread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, int reserved); 
\end_layout

\begin_layout Standard
This function is reserved for future expansion.
 The intention is to use it for diagnostic read commands (such as reading
 the raw bits from a track).
 Currently it returns DSK_ERR_NOTIMPL.
\end_layout

\begin_layout Subsection
dsk_xread, dsk_xwrite: Low-level reading and writing
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_xread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, dsk_pcyl_t cyl_expected, dsk_phead_t
 head_expected, dsk_psect_t sector, size_t sector_len, int *deleted); 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_xwrite(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const void
 *buf, dsk_pcyl_t cylinder, dsk_phead_t head, dsk_pcyl_t cyl_expected, dsk_phead
_t head_expected, dsk_psect_t sector, size_t sector_len, int deleted);
\end_layout

\begin_layout Standard
dsk_xread() and dsk_xwrite() are extended versions of dsk_pread() and dsk_pwrite
().
 They allow the caller to read/write sectors whose sector ID differs from
 the physical location of the sector, or to read/write deleted data..
 The 
\begin_inset Quotes eld
\end_inset

cylinder
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 arguments specify where to look; the 
\begin_inset Quotes eld
\end_inset

cyl_expected
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

head_expected
\begin_inset Quotes erd
\end_inset

 are the values to search for in the sector header.
 
\end_layout

\begin_layout Standard
These functions are only supported by the CPCEMU driver, the Linux floppy
 driver and the NTWDM floppy driver.
 Other drivers will return DSK_ERR_NOTIMPL.
 Unless you are emulating a floppy controller, or you need to read discs
 that contain deleted data or misnumbered sectors, it should not be necessary
 to call these functions.
\end_layout

\begin_layout Subsubsection
dsk_xread(), dsk_xwrite(): Deleted data 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

deleted
\begin_inset Quotes erd
\end_inset

 argument is used if you want to read or write sectors that have been marked
 as deleted.
 In 
\family typewriter
dsk_xwrite()
\family default
, this is a simple value; pass 0 to write normal data, or 1 to write deleted
 data.
 In 
\family typewriter
dsk_xread()
\family default
, pass the address of an integer containing 0 (read normal data) or 1 (read
 deleted data).
 On return, the integer will contain: 
\end_layout

\begin_layout Itemize
If the requested data type was read: 0 
\end_layout

\begin_layout Itemize
If the other data type was read: 1 
\end_layout

\begin_layout Itemize
If the command failed: Value is meaningless.
 
\end_layout

\begin_layout Standard
Passing 
\family typewriter
NULL
\family default
 acts the same as passing a pointer to 0.
\end_layout

\begin_layout Standard
The opposite type of data will only be read if you set 
\family typewriter
geom->dg_noskip
\family default
 to nonzero.
 Some examples:
\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
geom->dg_noskip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
deleted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data on disc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Results
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*deleted becomes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_OK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deleted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_NODATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
??
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deleted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_NODATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
??
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_OK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deleted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_OK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_OK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-> 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deleted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DSK_ERR_OK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Subsection
dsk_ltread, dsk_ptread, dsk_xtread 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_ltread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_ltrack_t track) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_ptread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_xtread(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, dsk_pcyl_t cyl_expected, dsk_phead_t
 head_expected)
\end_layout

\begin_layout Standard
These functions read a track from the disc, using the FDC's 
\begin_inset Quotes eld
\end_inset

READ TRACK
\begin_inset Quotes erd
\end_inset

 command.
 There are three of them - logical, physical and extended physical.
\end_layout

\begin_layout Standard
If the driver does not support this functionality, LibDsk will attempt to
 simulate it using multiple sector reads.
\end_layout

\begin_layout Standard
Enter with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 is a handle to an open drive / image file.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

geom
\begin_inset Quotes erd
\end_inset

 points to the geometry for the drive.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

buf
\begin_inset Quotes erd
\end_inset

 is the buffer into which data will be loaded.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

cylinder
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_ptread
\family default
, 
\family typewriter
dsk_xtread
\family default
) or 
\begin_inset Quotes eld
\end_inset

track
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
dsk_ltread
\family default
) give the location of the track to read.
 
\end_layout

\begin_layout Itemize
(
\family typewriter
dsk_xtread
\family default
) 
\begin_inset Quotes eld
\end_inset

cyl_expected
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

head_expected
\begin_inset Quotes erd
\end_inset

 are used as the values to search for in the sector headers.
 
\end_layout

\begin_layout Standard
Returns: 
\end_layout

\begin_layout Itemize
If successful, DSK_ERR_OK.
 Otherwise, a negative DSK_ERR_* value.
 
\end_layout

\begin_layout Itemize
(
\family typewriter
dsk_xtread()
\family default
 only) If the driver does not support extended sector reads/writes, then
 DSK_ERR_NOTIMPL will be returned.
\end_layout

\begin_layout Subsection
dsk_lseek, dsk_pseek 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_lseek(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_ltrack_t
 track)
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_pseek(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head)
\end_layout

\begin_layout Standard
Seek to a given cylinder.
 Only the CPCEMU driver, the Linux floppy driver and the NTWDM floppy driver
 support this; other drivers return DSK_ERR_NOTIMPL.
 You should not normally need to call these functions.
 They have been provided to support programs that emulate a uPD765A controller.
\end_layout

\begin_layout Subsection
dsk_drive_status 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_drive_status(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_phead
_t head, unsigned char *result)
\end_layout

\begin_layout Standard
Get the drive's status (ready, read-only etc.).
 The byte 
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

 will have one or more of the following bits set:
\end_layout

\begin_layout Description
DSK_ST3_FAULT: Drive fault 
\end_layout

\begin_layout Description
DSK_ST3_RO: Read-only 
\end_layout

\begin_layout Description
DSK_ST3_READY: Ready 
\end_layout

\begin_layout Description
DSK_ST3_TRACK0: Head is over track 0 
\end_layout

\begin_layout Description
DSK_ST3_DSDRIVE: Drive is double-sided 
\end_layout

\begin_layout Description
DSK_ST3_HEAD1: Current head is head 1, not head 0.
 Usually this just depends on the value of the 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 parameter to this function.
 
\end_layout

\begin_layout Standard
Which bits will be 
\begin_inset Quotes eld
\end_inset

live
\begin_inset Quotes erd
\end_inset

 depends on which driver is in use, but the most trustworthy will be DSK_ST3_REA
DY and DSK_ST3_RO.
 This function will never return DSK_ERR_NOTIMPL; if the facility is not
 provided by the driver, a default version will be used.
 
\end_layout

\begin_layout Subsection
dsk_dirty: Has drive been written to?
\end_layout

\begin_layout LyX-Code
int dsk_dirty(DSK_PDRIVER self); 
\end_layout

\begin_layout Standard
This returns zero if the disc has not been written to since it was opened,
 nonzero if it has.
\end_layout

\begin_layout Subsection
dsk_getgeom: Guess disc geometry
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_getgeom(DSK_PDRIVER self, DSK_GEOMETRY *geom)
\end_layout

\begin_layout Standard
This attempts to determine the geometry of a disc (number of cylinders,
 tracks, sectors etc.) by loading the boot sector.
 It understands DOS, Apricot, CP/M-86 and PCW boot sectors.
 If the geometry could be guessed, then 
\begin_inset Quotes eld
\end_inset

geom
\begin_inset Quotes erd
\end_inset

 will be initialised and DSK_ERR_OK will be returned.
 If no guess could be made, then DSK_ERR_BADFMT will be returned.
 Other values will result if the disc could not be read.
\end_layout

\begin_layout Standard
Some drivers (in particular the MYZ80 driver, and the Win32 driver under
 NT) only support certain fixed disc geometries.
 In this case, the geometry returned will reflect what the driver can use,
 rather than what the boot sector says.
\end_layout

\begin_layout Subsection
dg_*geom : Initialise disc geometry from boot sector
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_dosgeom(DSK_GEOMETRY *self, const unsigned char *bootsect)
 
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_pcwgeom(DSK_GEOMETRY *self, const unsigned char *bootsect)
 
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_cpm86geom(DSK_GEOMETRY *self, const unsigned char *bootsect)
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_aprigeom(DSK_GEOMETRY *self, const unsigned char *bootsect)
\end_layout

\begin_layout Standard
These functions are used by 
\family typewriter
dsk_getgeom()
\family default
, but can also be called independently.
 Enter them with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 is the structure to initialise;
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

bootsect
\begin_inset Quotes erd
\end_inset

 is the boot sector to initialise the structure from.
\end_layout

\begin_layout Standard
Returns DSK_ERR_BADFMT if the sector does not contain a suitable disc specificat
ion, or DSK_ERR_OK otherwise.
\end_layout

\begin_layout Description
dg_dosgeom will check for a PC-DOS boot sector.
\end_layout

\begin_layout Description
dg_pcwgeom will check for an Amstrad PCW boot sector.
\end_layout

\begin_layout Description
dg_cpm86geom will check for a CP/M-86 boot sector.
\end_layout

\begin_layout Description
dg_aprigeom will check for an Apricot DOS boot sector.
\end_layout

\begin_layout Subsection
dg_stdformat : Initialise disc geometry from a standard LibDsk format.
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_stdformat(DSK_GEOMETRY *self, dsk_format_t formatid, dsk_cchar_t
 *fname, dsk_cchar_t *fdesc)
\end_layout

\begin_layout Standard
Initialises a DSK_GEOMETRY structure with one of the standard formats LibDsk
 knows about.
 Formats are:
\end_layout

\begin_layout Description
FMT_180K: 180k, 9 512 byte sectors, 40 tracks, 1 side 
\end_layout

\begin_layout Description
FMT_200K: 200k, 10 512 byte sectors, 40 tracks, 1 side 
\end_layout

\begin_layout Description
FMT_CPCSYS: Amstrad CPC system format - as FMT_180K, but physical sectors
 are numbered 65-73 
\end_layout

\begin_layout Description
FMT_CPCDATA: Amstrad CPC data format - as FMT_180K, but physical sectors
 are numbered 193-201 
\end_layout

\begin_layout Description
FMT_720K: 720k, 9 512 byte sectors, 80 tracks, 2 sides 
\end_layout

\begin_layout Description
FMT_800K: 800k, 10 512 byte sectors, 80 tracks, 2 sides 
\end_layout

\begin_layout Description
FMT_1440K: 1.4M, 18 512 byte sectors, 80 tracks, 2 sides 
\end_layout

\begin_layout Description
FMT_160K: 160k, 8 512 byte sectors, 40 tracks, 1 side 
\end_layout

\begin_layout Description
FMT_320K: As FMT_160K, but 2 sides 
\end_layout

\begin_layout Description
FMT_360K: As FMT_180K, but 2 sides 
\end_layout

\begin_layout Description
FMT_720F: As FMT_720K, but the physical/logical sector mapping is 
\begin_inset Quotes eld
\end_inset

out-and-back
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

alternate sides
\begin_inset Quotes erd
\end_inset

.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec: dskgeom"

\end_inset

 for details.
 
\end_layout

\begin_layout Description
FMT_1200F: As FMT_720F, but with 15 sectors 
\end_layout

\begin_layout Description
FMT_1440F: As FMT_720F, but with 18 sectors 
\end_layout

\begin_layout Description
FMT_ACORN160: Acorn 40 track single sided 160k (used by ADFS 'S' format)
 
\end_layout

\begin_layout Description
FMT_ACORN320: Acorn 80 track single sided 320k (used by ADFS 'M' format)
 
\end_layout

\begin_layout Description
FMT_ACORN640: Acorn 80 track double sided 640k (used by ADFS 'L' format)
 
\end_layout

\begin_layout Description
FMT_ACORN800: Acorn 80 track double sided 800k (used by ADFS 'D' and 'E')
 
\end_layout

\begin_layout Description
FMT_ACORN1600: Acorn 80 track high density 1600k (used by ADFS 'F' format)
 
\end_layout

\begin_layout Description
FMT_BBC100 BBC micro 40 track single sided 100k (using FM encoding) 
\end_layout

\begin_layout Description
FMT_BBC200 BBC micro 80 track single sided 200k (using FM encoding)
\end_layout

\begin_layout Description
FMT_MBEE400 Microbee 40 track double sided 400k
\end_layout

\begin_layout Description
FMT_MGT800 MGT 80 track double sided 800k (used by MGT +D and Sam Coupé).
\end_layout

\begin_layout Standard
If the 
\begin_inset Quotes eld
\end_inset

fname
\begin_inset Quotes erd
\end_inset

 is not NULL, it will be pointed at a short name for the format (suitable
 for use as a program option; see 
\family typewriter
tools/dskform.c
\family default
).
 
\end_layout

\begin_layout Standard
If the 
\begin_inset Quotes eld
\end_inset

fdesc
\begin_inset Quotes erd
\end_inset

 is not NULL, it will be pointed at a description string for the format.
 With these two, it's possible to enumerate geometries supported by the
 library without keeping a separate list in your program - see 
\family typewriter
tools/formnames.c
\family default
 for example code that does this.
\end_layout

\begin_layout Standard
If additional formats have been specified in the libdskrc file (section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:libdskrc-format"

\end_inset

), they will be returned by this function, using format numbers starting
 at the last builtin format plus 1.
\end_layout

\begin_layout Subsection
dsk_*_forcehead: Override disc head
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_set_forcehead(DSK_PDRIVER self, int force) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_get_forcehead(DSK_PDRIVER self, int *force)
\end_layout

\begin_layout Standard
(This function is deprecated; it is equivalent to dsk_set_option() / dsk_get_opt
ion() with 
\begin_inset Quotes eld
\end_inset

HEAD
\begin_inset Quotes erd
\end_inset

 as the option name).
\end_layout

\begin_layout Standard
Forces the driver to ignore the head number passed to it and always use
 either side 0 or side 1 of the disc.
 This is used to read discs recorded on PCW / CPC / Spectrum+3 add-on 3.5"
 drives.
 Instead of the system software being programmed to use both sides of the
 disc, a switch on the drive was used to set which side was being used.
 Thus discs would end up with both sides saying they were head 0.
\end_layout

\begin_layout Standard
Anyway, when using dsk_set_forcehead, pass: 
\end_layout

\begin_layout Description
-1: Normal - the head passed as a parameter to other calls is used.
 
\end_layout

\begin_layout Description
0: Always use side 0.
 
\end_layout

\begin_layout Description
1: Always use side 1.
\end_layout

\begin_layout Subsection
dsk_*_option: Set/get driver option
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_set_option(DSK_PDRIVER self, const char *name, int value)
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_get_option(DSK_PDRIVER self, const char *name, int *value)
\end_layout

\begin_layout Standard
Sets or gets a driver-specific numeric option.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 field is the option name.
 If the selected driver does not support the appropriate option, then the
 error DSK_ERR_BADOPT will be returned.
 If the option is valid but the value requested is not, DSK_ERR_BADVAL will
 be returned.
\end_layout

\begin_layout Standard
The following driver options are supported by the Linux and NTWDM floppy
 drivers:
\end_layout

\begin_layout Description
HEAD Force the drive always to use one or other side of the disc, ignoring
 the disc geometry.
 Valid values are 0 or 1 to force one or other side of the disc, -1 to allow
 either.
\end_layout

\begin_layout Description
DOUBLESTEP To support a 48tpi disc in a 96tpi drive, double all cylinder
 numbers.
 Valid values are 1 (enable) or 0 (disable).
\end_layout

\begin_layout Description
ST0
\begin_inset space ~
\end_inset

/
\begin_inset space ~
\end_inset

ST1
\begin_inset space ~
\end_inset

/
\begin_inset space ~
\end_inset

ST2
\begin_inset space ~
\end_inset

/
\begin_inset space ~
\end_inset

ST3 These are the values of the floppy controller's 4 status registers returned
 by the last operation.
 They cannot be changed, only read.
\end_layout

\begin_layout Standard
The 'remote' driver supports the following option (plus any options that
 the remote driver supports):
\end_layout

\begin_layout Description
REMOTE:TESTING This disables an optimisation in the remote driver, so that
 it sends method calls to the remote server even if it has been asked not
 to.
 The purpose of this is to ensure that all calls to the remote driver result
 in RPC packets being sent.
\end_layout

\begin_layout Subsubsection
Filesystem driver options
\end_layout

\begin_layout Standard
It is possible that as part of its geometry probe, LibDsk will have detected
 a CP/M or DOS filesystem on a disc image.
 Alternatively, a disc image may contain filesystem metadata (for example,
 the YAZE ydsk and RCPMFS drivers both contain CP/M filesystem parameters).
 These parameters appear as driver options, prefixed with the name FS:.
 When making a copy, dsktrans enumerates the driver options on the source
 disc image and sets them to the same values on the destination image.
 This is necessary to ensure that (for example) when one YDSK is copied
 to another, its filesystem parameters are transferred.
 The current filesystem options supported by LibDsk are:
\end_layout

\begin_layout Description
FS:CP/M:BSH Block shift - 3 => 1k, 4 => 2k, 5 => 4k...
\end_layout

\begin_layout Description
FS:CP/M:BLM Block mask - (block size / 128) - 1
\end_layout

\begin_layout Description
FS:CP/M:EXM Extent mask - roughly, how much does a directory entry cover?
 (0 => 16k, 1 => 32k, 3 => 64k...)
\end_layout

\begin_layout Description
FS:CP/M:DSM Number of data and directory blocks, minus 1
\end_layout

\begin_layout Description
FS:CP/M:DRM Number of directory entries, minus 1
\end_layout

\begin_layout Description
FS:CP/M:AL0 Allocation bitmap of directory blocks (first 8 blocks)
\end_layout

\begin_layout Description
FS:CP/M:AL1 Allocation bitmap of directory blocks (second 8 blocks)
\end_layout

\begin_layout Description
FS:CP/M:CKS Checksum vector size (normally (FS:CP/M:DRM + 1) / 4); can be
 0x8000 for a fixed disc
\end_layout

\begin_layout Description
FS:CP/M:OFF Number of boot tracks
\end_layout

\begin_layout Description
FS:CP/M:VERSION Filesystem version (-2 (ISX), 2 (CP/M 2) or 3 (CP/M 3).
 This is only supported by the 'rcpmfs' driver.)
\end_layout

\begin_layout Description
FS:FAT:SECCLUS Number of sectors per cluster
\end_layout

\begin_layout Description
FS:FAT:RESERVED Number of reserved sectors
\end_layout

\begin_layout Description
FS:FAT:FATCOPIES Number of FAT copies
\end_layout

\begin_layout Description
FS:FAT:DIRENTRIES Number of root directory entries
\end_layout

\begin_layout Description
FS:FAT:MEDIABYTE Media byte (usually the first byte of the FAT)
\end_layout

\begin_layout Description
FS:FAT:SECFAT Number of sectors per FAT
\end_layout

\begin_layout Standard
Note that it is theoretically possible for a disc to have FS:CP/M 
\emph on
and
\emph default
 FS:FAT information - for example, a CP/M filesystem saved in a disc image
 that also contains FAT metadata, or vice versa.
\end_layout

\begin_layout Subsection
dsk_option_enum: Get list of driver options
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_option_enum(DSK_PDRIVER self, int idx, char **optname)
\end_layout

\begin_layout Standard
If 
\begin_inset Quotes eld
\end_inset

idx
\begin_inset Quotes erd
\end_inset

 is in the range 0 -> number of driver options, (*optname) is set to the
 name of the appropriate driver option.
 If not, (*optname) is set to NULL.
\end_layout

\begin_layout Subsection
dsk_*_comment: Set comment for disc image
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_set_comment(DSK_PDRIVER self, const char *comment) 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_get_comment(DSK_PDRIVER self, char **comment)
\end_layout

\begin_layout Standard
Used to get or set the comment (if any) for the current disc.
 The pointer passed or returned may be NULL (meaning 
\begin_inset Quotes eld
\end_inset

No comment
\begin_inset Quotes erd
\end_inset

).
 The string returned belongs to LibDsk; don't alter or free it.
\end_layout

\begin_layout Subsection
dsk_type_enum 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_type_enum(int index, char **drvname)
\end_layout

\begin_layout Standard
If 
\begin_inset Quotes eld
\end_inset

index
\begin_inset Quotes erd
\end_inset

 is in the range 0 -> number of LibDsk drivers, (
\family typewriter
*drvname
\family default
) is set to the short name for that driver (eg: 
\begin_inset Quotes eld
\end_inset

myz80
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

).
 If not, (*drvname) is set to 
\family typewriter
NULL
\family default
.
\end_layout

\begin_layout Subsection
dsk_comp_enum 
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_comp_enum(int index, char **compname)
\end_layout

\begin_layout Standard
As 
\family typewriter
dsk_type_enum()
\family default
, but lists supported compression schemes.
\end_layout

\begin_layout Subsection
dsk_drvname, dsk_drvdesc 
\end_layout

\begin_layout LyX-Code
const char *dsk_drvname(DSK_PDRIVER self) 
\end_layout

\begin_layout LyX-Code
const char *dsk_drvdesc(DSK_PDRIVER self)
\end_layout

\begin_layout Standard
Returns the driver name (eg: 
\begin_inset Quotes eld
\end_inset

myz80
\begin_inset Quotes erd
\end_inset

) or description (eg 
\begin_inset Quotes eld
\end_inset

MYZ80 hard drive driver
\begin_inset Quotes erd
\end_inset

) for an open disc image.
\end_layout

\begin_layout Subsection
dsk_compname, dsk_compdesc 
\end_layout

\begin_layout LyX-Code
const char *dsk_compname(DSK_PDRIVER self); 
\end_layout

\begin_layout LyX-Code
const char *dsk_compdesc(DSK_PDRIVER self);
\end_layout

\begin_layout Standard
Returns the compression system name (eg: 
\begin_inset Quotes eld
\end_inset

gz
\begin_inset Quotes erd
\end_inset

; NULL if the disc image isn't compressed) or description (eg: 
\begin_inset Quotes eld
\end_inset

GZip compressed
\begin_inset Quotes erd
\end_inset

) for an open disc image.
\end_layout

\begin_layout Subsection
dg_ps2ls, dg_ls2ps, dg_pt2lt, dg_lt2pt 
\end_layout

\begin_layout Standard
Convert between logical sectors and physical cylinder/head/sector addresses.
 Normally these functions are called internally and you don't need to use
 them.
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_ps2ls(const DSK_GEOMETRY *self, dsk_pcyl_t cyl, dsk_phead_t
 head, dsk_psect_t sec, dsk_lsect_t *logical)
\end_layout

\begin_layout Standard
Converts physical C/H/S to logical sector.
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_ls2ps(const DSK_GEOMETRY *self, dsk_lsect_t logical, dsk_pcyl_t
 *cyl, dsk_phead_t *head, dsk_psect_t *sec)
\end_layout

\begin_layout Standard
Converts logical sector to physical C/H/S.
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_pt2lt(const DSK_GEOMETRY *self, dsk_pcyl_t cyl, dsk_phead_t
 head, dsk_ltrack_t *logical)
\end_layout

\begin_layout Standard
Converts physical C/H to logical track.
\end_layout

\begin_layout LyX-Code
dsk_err_t dg_lt2pt(const DSK_GEOMETRY *self, dsk_ltrack_t logical, dsk_pcyl_t
 *cyl, dsk_phead_t *head)
\end_layout

\begin_layout Standard
Converts logical track to physical C/H.
\end_layout

\begin_layout Subsection
dsk_strerror: Convert error code to string
\end_layout

\begin_layout LyX-Code
char *dsk_strerror(dsk_err_t err)
\end_layout

\begin_layout Standard
Converts an error code returned by one of the other LibDsk functions into
 a printable string.
\end_layout

\begin_layout Subsection
dsk_reportfunc_set / dsk_reportfunc_get
\end_layout

\begin_layout LyX-Code
void dsk_reportfunc_set(DSK_REPORTFUNC report, DSK_REPORTEND repend);
\end_layout

\begin_layout LyX-Code
void dsk_reportfunc_get(DSK_REPORTFUNC *report, DSK_REPORTEND *repend);
\end_layout

\begin_layout Standard
Used to set callbacks from LibDsk to your own code, for LibDsk to display
 messages during processing that may take time.
 The code could be used to set the text on the status line of your program
 window, for example.
\end_layout

\begin_layout LyX-Code
typedef void (*DSK_REPORTFUNC)(const char *message); 
\end_layout

\begin_layout LyX-Code
typedef void (*DSK_REPORTEND)(void);
\end_layout

\begin_layout Standard
The first function you provide will be called when LibDsk wants to display
 a message (such as 
\begin_inset Quotes eld
\end_inset

Decompressing...
\begin_inset Quotes erd
\end_inset

).
 The second will be called when the processing has finished.
\end_layout

\begin_layout Subsection
dsk_set_retry / dsk_get_retry
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_set_retry(DSK_PDRIVER self, unsigned int count);
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_get_retry(DSK_PDRIVER self, unsigned int *count);
\end_layout

\begin_layout Standard
Sets the number of times that a failed read, write, check or format operation
 will be attempted.
 1 means 
\begin_inset Quotes eld
\end_inset

only try once, do not retry
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsection
dsk_get_psh 
\end_layout

\begin_layout LyX-Code
unsigned char dsk_get_psh(size_t sector_size)
\end_layout

\begin_layout Standard
Converts a sector size into the sector shift used by the uPD765A controller
 (eg: 128 -> 0, 256 -> 1, 512 -> 2 etc.) You should not need to use this.
 The reverse operation is: sectorsize = (128 << psh).
\end_layout

\begin_layout Subsection
dsk_copy: Copy an entire disk image
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_copy(DSK_PDRIVER source, DSK_PDRIVER dest, DSK_GEOMETRY *geom);
 
\end_layout

\begin_layout Standard
This will copy all data possible from one disk image to another.
 It only works on disc image files; attempts to use it on floppy drives,
 remote servers and so forth will return DSK_ERR_NOTIMPL.
 
\end_layout

\begin_layout Standard
The 'geom' parameter is usually left as NULL.
 Most disk image files contain enough metadata that their structure can
 be determined unambiguously.
 Raw files (formats 'raw', 'rawoo', 'rawob' and 'logical') do not.
 If the source or the target is one of these files, the copy may fail with
 DSK_ERR_BADFMT.
 If so, a 'geom' parameter should be passed, describing the layout to use.
\end_layout

\begin_layout Subsection
Structure: DSK_FORMAT
\end_layout

\begin_layout Standard
This structure is used to represent a sector header.
 It has four members:
\end_layout

\begin_layout Description
fmt_cylinder: Cylinder number.
 
\end_layout

\begin_layout Description
fmt_head: Head number.
 
\end_layout

\begin_layout Description
fmt_sector: Sector number.
 
\end_layout

\begin_layout Description
fmt_secsize: Sector size in bytes.
\end_layout

\begin_layout Subsection
LibDsk errors 
\end_layout

\begin_layout Description
DSK_ERR_OK: No error.
\end_layout

\begin_layout Description
DSK_ERR_BADPTR: A null or otherwise invalid pointer was passed to a LibDsk
 routine.
 
\end_layout

\begin_layout Description
DSK_ERR_DIVZERO: Division by zero: For example, a DSK_GEOMETRY is set to
 have zero sectors.
 
\end_layout

\begin_layout Description
DSK_ERR_BADPARM: Bad parameter (eg: if a DSK_GEOMETRY is set up with 
\family typewriter
dg_cylinders
\family default
 = 40, trying to convert a sector in cylinder 65 to a logical sector will
 give this error).
 
\end_layout

\begin_layout Description
DSK_ERR_NODRVR: Requested driver not found in 
\family typewriter
dsk_open()
\family default
 / 
\family typewriter
dsk_creat()
\family default
.
 
\end_layout

\begin_layout Description
DSK_ERR_NOTME: Disc image could not be opened by requested driver.
\end_layout

\begin_layout Description
DSK_ERR_SYSERR: System call failed.
 errno holds the reason.
 
\end_layout

\begin_layout Description
DSK_ERR_NOMEM: 
\family typewriter
malloc()
\family default
 failed to allocate memory.
 
\end_layout

\begin_layout Description
DSK_ERR_NOTIMPL: Function is not implemented (eg, this driver doesn't support
 
\family typewriter
dsk_xread()
\family default
).
 
\end_layout

\begin_layout Description
DSK_ERR_MISMATCH: In 
\family typewriter
dsk_lcheck()
\family default
 / 
\family typewriter
dsk_pcheck()
\family default
, sectors didn't match.
 
\end_layout

\begin_layout Description
DSK_ERR_NOTRDY: Drive is not ready.
 
\end_layout

\begin_layout Description
DSK_ERR_RDONLY: Disc is read-only.
 
\end_layout

\begin_layout Description
DSK_ERR_SEEKFAIL: Seek fail.
 
\end_layout

\begin_layout Description
DSK_ERR_DATAERR: Data error.
 
\end_layout

\begin_layout Description
DSK_ERR_NODATA: Sector ID found, but not sector data.
 
\end_layout

\begin_layout Description
DSK_ERR_NOADDR: Sector not found at all.
 
\end_layout

\begin_layout Description
DSK_ERR_BADFMT: Not a valid format.
 
\end_layout

\begin_layout Description
DSK_ERR_CHANGED: Disc has been changed unexpectedly.
 
\end_layout

\begin_layout Description
DSK_ERR_ECHECK: Equipment check.
 
\end_layout

\begin_layout Description
DSK_ERR_OVERRUN: Overrun.
 
\end_layout

\begin_layout Description
DSK_ERR_ACCESS: Access denied.
 
\end_layout

\begin_layout Description
DSK_ERR_CTRLR: Controller failed.
 
\end_layout

\begin_layout Description
DSK_ERR_COMPRESS: Compressed file is corrupt.
 
\end_layout

\begin_layout Description
DSK_ERR_RPC: Error in remote procedure call.
\end_layout

\begin_layout Description
DSK_ERR_BADOPT: Driver does not support the requested option.
\end_layout

\begin_layout Description
DSK_ERR_BADVAL: Driver does support the requested option, but the passed
 value is out of range.
\end_layout

\begin_layout Description
DSK_ERR_UNKNOWN: Unknown error
\end_layout

\begin_layout Subsection
Miscellaneous 
\end_layout

\begin_layout Standard
LIBDSK_VERSION is a macro, defined as a string containing the library version
 - eg 
\begin_inset Quotes eld
\end_inset

1.0.0
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Initialisation files
\end_layout

\begin_layout Standard
In addition to its built-in library of formats, LibDsk can also load formats
 from one or two external files - a systemwide file (libdskrc) and a user-specif
ic file (.libdskrc).
 The rules for how these files are found differ from platform to platform.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:libdskrc-format"

\end_inset

libdskrc format
\end_layout

\begin_layout Standard
The file format is similar to a Windows .INI file.
 Each format is described in a section, which starts with the format name
 in square brackets (format names may not start with a hyphen).
 After the format name, there are a number of lines of the form variable=value.
\end_layout

\begin_layout Standard
Anything after a semicolon or hash character is treated as a comment and
 ignored.
 Blank lines are also ignored.
 
\end_layout

\begin_layout Standard
For each geometry, the entries listed below can be present.
 If not all the values are present, LibDsk will use default values from
 its "pcw180" format.
 As you can see, they correspond to members of the DSK_GEOMETRY structure.
\end_layout

\begin_layout Description
description=DESC The description of the format as shown by (for example)
 dskform --help.
 
\end_layout

\begin_layout Description
sides=TREATMENT How a double-sided disk is handled.
 This can either be 
\emph on
alt
\emph default
 (sides alternate -- used by most PC-hosted operating systems), 
\emph on
outback
\emph default
 (use side 0 tracks 0-79, then side 1 tracks 79-0 -- used by 144FEAT CP/M
 disks), 
\emph on
outout
\emph default
 (use side 0 tracks 0-79, then side 1 tracks 0-79 -- used by some Acorn
 formats) or 
\emph on
extsurface
\emph default
 (sectors on side 0 are numbered 1-
\emph on
n
\emph default
, sectors on side 1 are numbered 
\emph on
n
\emph default
+1 - 
\emph on
n
\emph default
*2).
 If the disk is single-sided, this parameter can be omitted.
\end_layout

\begin_layout Description
cylinders=COUNT Sets the number of cylinders (usually 40 or 80).
 
\end_layout

\begin_layout Description
heads=COUNT Sets the number of heads (usually 1 or 2 for single- or double-
 sided).
\end_layout

\begin_layout Description
sectors=COUNT Sets the number of sectors per track.
 
\end_layout

\begin_layout Description
secbase=NUMBER Sets the first sector number on a track.
 Usually 1; some Acorn formats use 0.
 
\end_layout

\begin_layout Description
secsize=COUNT Sets the size of a sector in bytes.
 This should be a power of 2.
\end_layout

\begin_layout Description
datarate=VALUE Sets the rate at which the disk should be accessed.
 This is one of 
\emph on
HD, DD, SD or ED.
\end_layout

\begin_layout Description
rwgap=VALUE Sets the read/write gap.
\end_layout

\begin_layout Description
fmtgap=VALUE Sets the format gap.
\end_layout

\begin_layout Description
recmode=FM
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

MFM Sets the recording mode - FM or MFM.
 For backward compatibility, the alternate syntax 
\series bold
FM=Y or N
\series default
 is also supported.
\end_layout

\begin_layout Description
complement=Y
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

N Sets the complement flag - Y if the format stores data complemented.
\end_layout

\begin_layout Description
multitrack=Y
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

N Sets multitrack mode.
\end_layout

\begin_layout Description
skipdeleted=Y
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

N Sets whether to skip deleted data.
\end_layout

\begin_layout Subsubsection
libdskrc example
\end_layout

\begin_layout LyX-Code
; This is FMT_800K as a libdskrc entry
\end_layout

\begin_layout LyX-Code
[xcf2dd] 
\end_layout

\begin_layout LyX-Code
Description = 800k XCF2DD format 
\end_layout

\begin_layout LyX-Code
Sides = Alt 
\end_layout

\begin_layout LyX-Code
Cylinders = 80    
\end_layout

\begin_layout LyX-Code
Heads = 2 
\end_layout

\begin_layout LyX-Code
Sectors = 10 
\end_layout

\begin_layout LyX-Code
SecBase = 1 
\end_layout

\begin_layout LyX-Code
SecSize = 512 
\end_layout

\begin_layout LyX-Code
DataRate = SD 
\end_layout

\begin_layout LyX-Code
RWGap = 12 
\end_layout

\begin_layout LyX-Code
FmtGap = 23
\end_layout

\begin_layout LyX-Code
RecMode = MFM
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
[xcf2]
\end_layout

\begin_layout LyX-Code
Description = 200k XCF2 format
\end_layout

\begin_layout LyX-Code
Cylinders = 40
\end_layout

\begin_layout Standard
...
 etc.
\end_layout

\begin_layout Standard
The supplied libdskrc.sample file contains libdskrc-format definitions of
 all the built-in disk formats.
\end_layout

\begin_layout Subsection
Locating libdskrc
\end_layout

\begin_layout Subsubsection

\noun on
Unix
\end_layout

\begin_layout Standard
The systemwide file is located at ${datadir}/LibDsk/libdskrc.
 The ${datadir} is usually /usr/local/share; you can change it with the
 --datadir or --prefix arguments to the configure script.
 
\end_layout

\begin_layout Standard
The user-specific file is $(HOME)/.libdskrc.
 
\end_layout

\begin_layout Subsubsection
Win32
\end_layout

\begin_layout Standard
The systemwide file is in the path specified at
\end_layout

\begin_layout LyX-Code
HKEY_LOCAL_MACHINE
\backslash
Software
\backslash
jce@seasip
\backslash
LibDsk
\backslash
ShareDir
\end_layout

\begin_layout Standard
If this registry key is not found, LibDsk finds the path of the program
 that called it (using GetModuleFileName()), and then uses 
\begin_inset Quotes eld
\end_inset

/...program path.../share/libdskrc
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The user-specific file is in the path specified at
\end_layout

\begin_layout LyX-Code
HKEY_CURRENT_USER
\backslash
Software
\backslash
jce@seasip
\backslash
LibDsk
\backslash
HomeDir
\end_layout

\begin_layout Standard
If this registry key is not present, the user's 
\begin_inset Quotes eld
\end_inset

My Documents
\begin_inset Quotes erd
\end_inset

 directory is used.
 Either way, the file is called .libdskrc.
\end_layout

\begin_layout Subsubsection
Win16
\end_layout

\begin_layout Standard
The systemwide file is found from the location of the calling program using
 GetModuleFileName().
 There is no user-specific file.
\end_layout

\begin_layout Subsubsection
DOS
\end_layout

\begin_layout Standard
The systemwide file is only searched for if the LIBDSK environment variable
 is set; if it is set, it is assumed to be the name of the directory containing
 libdskrc.
 There is no user-specific file.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:rcpmfs"

\end_inset

Reverse CP/M-FS (rcpmfs) backend
\end_layout

\begin_layout Standard
The rcpmfs backend is designed to present a host directory as a read/write
 CP/M disk image.
 This has a number of uses:
\end_layout

\begin_layout Itemize
You could construct a CP/M disk image using dsktrans 
\emph on
directory filename
\emph default
 .
\end_layout

\begin_layout Itemize
Conversely, you could extract the files from a CP/M disk image using dsktrans
 
\emph on
filename directory
\emph default
.
\end_layout

\begin_layout Itemize
It is possible for a CP/M emulator running a genuine copy of CP/M to use
 LibDsk to access files on the host system, without altering the BDOS or
 installing additional drivers.
 
\end_layout

\begin_layout Standard
rcpmfs does not work with systems that only support 
\begin_inset Quotes eld
\end_inset

8.3
\begin_inset Quotes erd
\end_inset

 format filenames; it also needs a system call that can set the size of
 a file (such as truncate() under 
\noun on
Unix
\noun default
).
 It therefore remains unimplemented in the DOS and Win16 versions of the
 library.
 
\end_layout

\begin_layout Subsection
In Use
\end_layout

\begin_layout Standard
To use an rcpmfs directory in LibDsk, pass a directory name instead of a
 filename.
 Files in the directory which match CP/M naming conventions (8.3 filenames)
 will appear in the emulated disk image; if there are more files than will
 fit in the emulated disk, LibDsk will stop when it reaches one that doesn't
 fit.
 Under Windows, the 'short filename' is used, so files with names not matching
 CP/M conventions may also be mapped with names like README~1.HTM.
 
\end_layout

\begin_layout Standard
CP/M has 16 user areas (some variants support 32; rcpmfs does not), and
 files with the same name can exist in each area.
 rcpmfs represents nonzero user areas by prepending 
\begin_inset Quotes eld
\end_inset

nn..
\begin_inset Quotes erd
\end_inset

 to the filename; so if a CP/M program created a file called EXAMPLE.DAT
 in user 4, this would be saved as 
\begin_inset Quotes eld
\end_inset

04..example.dat
\begin_inset Quotes erd
\end_inset

 in the underlying directory.
 The double dot ensures that the resulting filename is not a valid CP/M
 name, and therefore won't conflict with any file in user 0.
\end_layout

\begin_layout Standard
rcpmfs can behave as a CP/M 2 or CP/M 3 filesystem.
 If the latter, it constructs a disc label (based on the name of the directory)
 and turns on date/time stamping.
 Update and access stamps are used, because they map nicely to the utime()
 system call.
 It can also emulate the filesystem used by the ISX emulator, which stores
 file sizes slightly differently.
\end_layout

\begin_layout Subsection
rcpmfs initialisation file
\end_layout

\begin_layout Standard
For a directory to be usable by rcpmfs, it should contain a file called
 .libdsk.ini describing the format to use.
 This file is in INI format, similar to libdskrc (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:libdskrc-format"

\end_inset

).
 It must contain only one section: [RCPMFS].
 Within that section, the following variables may be present:
\end_layout

\begin_layout Description
BlockSize Size of a CP/M data block.
 Must be a power of 2, and at least 1024.
 If there are more than 255 blocks in the CP/M filesystem, this must be
 at least 2048.
\end_layout

\begin_layout Description
DirBlocks Number of blocks containing the CP/M directory.
\end_layout

\begin_layout Description
TotalBlocks Total number of data and directory blocks.
\end_layout

\begin_layout Description
SysTracks Number of system tracks.
 These will be stored in a file called .libdsk.boot.
 
\end_layout

\begin_layout Description
Version CP/M version that will be accessing the filesystem.
 This should be 2, 3 or ISX:
\end_layout

\begin_deeper
\begin_layout Description
2 CP/M 2 -- no time stamps or disk labels.
\end_layout

\begin_layout Description
3 CP/M 3 -- time stamps and disk labels are present.
\end_layout

\begin_layout Description
ISX Used by the ISX emulator.
 Similar to CP/M 2, but byte 13 of the CP/M directory entry holds the number
 of 
\emph on
unused
\emph default
 bytes in the last record, not the number of 
\emph on
used
\emph default
 bytes.
\end_layout

\end_deeper
\begin_layout Description
Format Name of one of the LibDsk built-in or user-supplied formats, giving
 the geometry that the simulated disk will have.
 Alternatively, you can specify the format manually, using the same variable
 names as in libdskrc.
\end_layout

\begin_layout Standard
If there is no .libdsk.ini file present, LibDsk will assume BlockSize=1024,
 DirBlocks=2, TotalBlocks=175,SysTracks=1, Version=3, Format=pcw180.
\end_layout

\begin_layout Standard
If you call dsk_option_set with any of the following options:
\end_layout

\begin_layout Itemize
FS:CP/M:BSH 
\end_layout

\begin_layout Itemize
FS:CP/M:BLM 
\end_layout

\begin_layout Itemize
FS:CP/M:DSM 
\end_layout

\begin_layout Itemize
FS:CP/M:DRM 
\end_layout

\begin_layout Itemize
FS:CP/M:OFF
\end_layout

\begin_layout Itemize
FS:CP/M:VERSION
\end_layout

\begin_layout Standard
and the value written differs from the one used before, then a new .libdsk.ini
 file will be written with the revised filesystem parameters and the directory
 rescanned.
 This allows a command of the form:
\end_layout

\begin_layout LyX-Code
dsktrans -otype rcpmfs disc-image directory
\end_layout

\begin_layout Standard
to stand a reasonable chance of working as long as the source disc image
 has a CP/M filesystem that LibDsk can detect.
\end_layout

\begin_layout Standard
To select ISX format using dsk_option_set(), use -2 as the filesystem version:
\end_layout

\begin_layout LyX-Code
dsk_set_option(dsk, 
\begin_inset Quotes eld
\end_inset

FS:CP/M:VERSION
\begin_inset Quotes erd
\end_inset

, -2);
\end_layout

\begin_layout Subsection
Bugs
\end_layout

\begin_layout Standard
rcpmfs is not without its bugs and missing features:
\end_layout

\begin_layout Itemize
To my knowledge, rcpmfs has only been tested under the dsktrans pattern
 of usage (which writes the directory and then the file space), and with
 fairly simple operations in a CP/M emulator.
 It is not known how well it holds up under heavy use as a live CP/M filesystem.
\end_layout

\begin_layout Itemize
The CP/M attributes F1-F4, passwords and permissions are not mapped.
 The SYS and ARC attributes are only mapped in the Win32 version.
\end_layout

\begin_layout Itemize
Formatting (or reformatting) an rcpmfs directory writes out a new .libdsk.ini
 containing the geometry used to do the format.
 However, since DSK_GEOMETRY doesn't contain the CP/M filesystem parameters
 (block size, block count, etc.) these will be the ones previously used in
 that directory, and quite possibly completely wrong.
 If you want to 'format' the directory using LibDsk, call dsk_set_option()
 with the six 
\begin_inset Quotes eld
\end_inset

FS:CP/M:
\begin_inset Quotes erd
\end_inset

 options listed above to set up the correct filesystem parameters.
 Or create the .libdsk.ini by other means.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "ldwindows"

\end_inset

LibDsk under Windows
\end_layout

\begin_layout Standard
This section mainly deals with the subject of direct floppy drive access.
 Other aspects of LibDsk remain relatively consistent across Windows versions.
\end_layout

\begin_layout Standard
As with so many other aspects of Windows, direct access to the floppy drive
 is a case of 
\begin_inset Quotes eld
\end_inset

write once - debug everywhere
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Originally said by Microsoft with respect to Java.
 Pot.
 Kettle.
 Black.
\end_layout

\end_inset

.
 Not only does support vary across different systems, it varies depending
 on whether LibDsk was compiled with a 16-bit compiler or a 32-bit one.
 This table shows the different possibilities and the resulting behaviour:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Windows Version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Win16 Subsystem
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Win32 Subsystem
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fairly good
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n/a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.x (95, 98 and ME)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Good but less stable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Limited
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NT, 2000, XP
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Very limited
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000, XP + ntwdm driver
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Good
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Windows 3.x
\end_layout

\begin_layout Standard
Only the 16-bit build of LibDsk will run.
 The floppy support in Win16 is pretty much the same as in DOS; there is
 support for discs with arbitrary numbers of tracks and sectors, and arbitrary
 sector sizes.
 This means that LibDsk can, for example, read Acorn ADFS floppies.
 
\end_layout

\begin_layout Subsection
Windows 4.x (95, 98 and ME)
\end_layout

\begin_layout Standard
Both the 16-bit and 32-bit versions of LibDsk will run.
 The 16-bit version is more capable, but less stable; it can read Acorn
 ADFS floppies, which the 32-bit version cannot.
 Unfortunately, 32-bit programs can't link to the 16-bit version of LibDsk
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
And no, the Generic Thunk isn't good enough.
 I've tried it.
\end_layout

\end_inset

, but there is a workaround (described below) involving the use of LDSERVER.
\end_layout

\begin_layout Subsection
Windows NT (NT 3.x, NT 4.x, 2000, XP) without ntwdm driver
\end_layout

\begin_layout Standard
The floppy drive can only read/write formats which are supported by the
 floppy driver.
 This is the case using either version of LibDsk.
\end_layout

\begin_layout Subsection
Windows 2000 and XP with ntwdm driver
\end_layout

\begin_layout Standard
Simon Owen's enhancement to the Windows 2000 floppy driver can be downloaded
 from <http://simonowen.com/fdrawcmd/>.
 Once it is installed, LibDsk (using its 'ntwdm' driver rather than 'floppy')
 has pretty much carte blanche regarding floppy formats, and can access
 discs in many formats including Acorn ADFS.
\end_layout

\begin_layout Subsection
General comments on programming floppy access for Windows
\end_layout

\begin_layout Standard
LibDsk has four independent drivers for accessing floppies under Windows.
 They are:
\end_layout

\begin_layout Subsubsection
The Win16 driver.
 
\end_layout

\begin_layout Standard
This uses INT 0x13 to do the reads and writes, just as in MSDOS.
 Again as in MSDOS, there is a diskette parameter table pointed to by INT
 0x1E.
 This table seems not to be documented, which is perhaps why the Win16 subsystem
 in Windows 2000/XP doesn't implement it.
 You can, fortunately, tell if this is the case; if the first two bytes
 are both 0xC4, then what you have is a Windows 2000 trap rather than a
 diskette parameter table.
 
\end_layout

\begin_layout Subsubsection
The Win32c driver.
\end_layout

\begin_layout Standard
This driver uses VWIN32 services to make INT 0x13-style calls under Windows9x.
 However, there is no VWIN32 call to change the diskette parameter table,
 which is why the Win16 driver can do things the Win32 drivers can't.
 It isn't possible to get round this by thunking to a 16-bit DLL either;
 the INT 0x1E vector is zero for 16-bit DLLs in 32-bit processes.
\end_layout

\begin_layout Subsubsection
The Win32 driver.
\end_layout

\begin_layout Standard
Windows NT gets close (but not close enough) to the UNIX idea that everything
 is a file.
 So while in theory it would be enough to use the normal 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 driver on 
\begin_inset Quotes eld
\end_inset


\family typewriter

\backslash

\backslash
.
\backslash
A:
\family default

\begin_inset Quotes eld
\end_inset

 , in practice there are a number of nasty subtleties relating to such things
 as memory alignment and file locking.
\end_layout

\begin_layout Subsubsection
The ntwdm driver.
\end_layout

\begin_layout Standard
This driver is a wrapper around fdrawcmd.sys, which allows commands to be
 issued to the floppy controller.
 
\end_layout

\begin_layout Subsubsection
Other floppy APIs
\end_layout

\begin_layout Standard
Sydex produce a replacement floppy driver for 32-bit versions of Windows
 (SydexFDD) which is not supported by LibDsk.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "ldserver"

\end_inset

LDSERVER
\end_layout

\begin_layout Standard
LDSERVER is a program that makes the 16-bit LibDsk DLL available to 32-bit
 programs.
 It does this by creating a mailslot (
\begin_inset Quotes eld
\end_inset


\family typewriter

\backslash

\backslash
.
\backslash
mailslot
\backslash
LibDsk16
\family default

\begin_inset Quotes erd
\end_inset

) and listening for messages.
 Each message corresponds to a LibDsk call.
\end_layout

\begin_layout Standard
The 32-bit LibDsk library checks for this mailslot and, if it finds it,
 uses it in preference to its own floppy support.
\end_layout

\begin_layout Subsubsection
Compiling LDSERVER
\end_layout

\begin_layout Standard
A compiled version of LDSERVER is not supplied.
 You will need to build it yourself from the files in the rpcserv directory;
 projects are provided for Microsoft Visual C++ 1.5 and Borland C++ 5.0.
\end_layout

\begin_layout Standard
LDSERVER calls functions in NETAPI.DLL.
 If your compiler doesn't include an import library for this DLL, you will
 have to generate it using the IMPLIB tool - eg:
\end_layout

\begin_layout LyX-Code
IMPLIB NETAPI.LIB NETAPI.DLL
\end_layout

\begin_layout Standard
or the equivalent utility for your compiler.
\end_layout

\begin_layout Subsubsection
Using LDSERVER
\end_layout

\begin_layout Standard
Just run LDSERVER.EXE, and then use a 32-bit LibDsk program.
 The server window shows a reference count (0 if it is idle, nonzero if
 LibDsk programs are using it) and the status should change to 
\begin_inset Quotes eld
\end_inset

Active
\begin_inset Quotes erd
\end_inset

 when it is performing disc access.
\end_layout

\begin_layout Standard
LDSERVER does not shut down automatically.
 
\end_layout

\begin_layout Subsubsection
Important Security Warning
\end_layout

\begin_layout Standard
LDSERVER is a 16-bit program, written using APIs intended for use on a local
 area network.
 These APIs have no security support.
 It will happily obey commands sent from anywhere on your network.
 If your computer is connected to the Internet, it will obey commands sent
 to it over the Internet.
 A malicious attacker could use LDSERVER to overwrite important system files
 or read confidential documents.
\end_layout

\begin_layout Standard
If you have a firewall, then make sure that the NetBIOS ports 137, 138 and
 139 are blocked.
 If you don't have a firewall, 
\series bold
\emph on
do not run LDSERVER while your computer is connected to the Internet!
\end_layout

\begin_layout Subsection
LibDsk and COM
\end_layout

\begin_layout Standard
If you are building the 32-bit version of LibDsk with Visual C++ 6.0, you
 can also build the accompanying 'atlibdsk' project, which builds a version
 of LibDsk that exports its API through COM.
 This allows relatively easy use of LibDsk from languages that support COM
 binding, such as Visual BASIC or .NET languages.
\end_layout

\begin_layout Subsubsection
General points
\end_layout

\begin_layout Standard
Where LibDsk functions return a dsk_err_t, ATLIBDSK returns a COM HRESULT.
 This will be S_OK for success, a general COM error (such as E_POINTER or
 E_INVALIDARG), or a FACILITY_ITF error (0x8004xxxx).
 The low word of a FACILITY_ITF error is the LibDsk error code, converted
 to a positive number (eg: 0x8004000C is FACILITY_ITF error 12, so the LibDsk
 error is -12, DSK_ERR_SEEKFAIL).
\end_layout

\begin_layout Standard
Sector buffers to be read/written must be passed as variants containing
 arrays of bytes.
 
\end_layout

\begin_layout Standard
The arrays of DSK_FORMAT structures passed to dsk_lform() and dsk_pform()
 are replaced by variants containing arrays of bytes - four bytes per sector
 to format.
 The last byte is the physical sector shift (0 for 128, 1 for 256 etc.)
\end_layout

\begin_layout Standard
ATLIBDSK exports four object classes: 
\end_layout

\begin_layout Subsubsection
Library
\end_layout

\begin_layout Standard
This contains LibDsk functions not associated with a particular disk image.
 Its methods are:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equivalent LibDsk call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
open 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dsk_open
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Disk object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dsk_creat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Disk object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
get_psh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dsk_get_psh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dosgeom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dg_dosgeom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Geometry object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cpm86geom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dg_cpm86geom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Geometry object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pcwgeom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dg_pcwgeom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Geometry object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aprigeom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dg_aprigeom
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Geometry object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stdformat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dg_stdformat
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instantiates a new Geometry object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stdformat_count
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns the number of formats supported by stdformat
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type_enum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dsk_type_enum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns TRUE if the passed index is valid, else FALSE.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
comp_enum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dsk_comp_enum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Returns TRUE if the passed index is valid, else FALSE.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reporter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dsk_reportfunc_{set,get}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
This is a property of type IReporter
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Geometry
\end_layout

\begin_layout Standard
This corresponds to the DSK_GEOMETRY structure.
 The following properties correspond to the structure members:
\end_layout

\begin_layout Itemize
sidedness
\end_layout

\begin_layout Itemize
cylinders
\end_layout

\begin_layout Itemize
heads
\end_layout

\begin_layout Itemize
sectors
\end_layout

\begin_layout Itemize
secbase
\end_layout

\begin_layout Itemize
datarate
\end_layout

\begin_layout Itemize
secsize
\end_layout

\begin_layout Itemize
rwgap
\end_layout

\begin_layout Itemize
fmtgap
\end_layout

\begin_layout Itemize
fm
\end_layout

\begin_layout Itemize
nomulti
\end_layout

\begin_layout Itemize
noskip
\end_layout

\begin_layout Standard
There are also five functions.
 Four are for logical/physical sector conversions:
\end_layout

\begin_layout Itemize
ls2ps
\end_layout

\begin_layout Itemize
lt2pt
\end_layout

\begin_layout Itemize
ps2ls
\end_layout

\begin_layout Itemize
pt2lt
\end_layout

\begin_layout Standard
and the last is stdformat(), which wraps dg_stdformat().
\end_layout

\begin_layout Subsubsection
Disk
\end_layout

\begin_layout Standard
The Disk object corresponds to a LibDsk DSK_PDRIVER value.
 You should not create one yourself (method calls will fail with E_POINTER)
 but call the 'create' or 'open' methods of the Library object.
\end_layout

\begin_layout Standard
Functions included are:
\end_layout

\begin_layout Itemize
get_geometry
\end_layout

\begin_layout Itemize
close
\end_layout

\begin_layout Itemize
drive_status
\end_layout

\begin_layout Itemize
pread
\end_layout

\begin_layout Itemize
lread
\end_layout

\begin_layout Itemize
xread
\end_layout

\begin_layout Itemize
pwrite
\end_layout

\begin_layout Itemize
lwrite
\end_layout

\begin_layout Itemize
xwrite
\end_layout

\begin_layout Itemize
pcheck
\end_layout

\begin_layout Itemize
lcheck
\end_layout

\begin_layout Itemize
xcheck
\end_layout

\begin_layout Itemize
pformat
\end_layout

\begin_layout Itemize
lformat
\end_layout

\begin_layout Itemize
apform
\end_layout

\begin_layout Itemize
alform
\end_layout

\begin_layout Itemize
ptread
\end_layout

\begin_layout Itemize
ltread
\end_layout

\begin_layout Itemize
xtread
\end_layout

\begin_layout Itemize
psecid 
\end_layout

\begin_layout Itemize
lsecid
\end_layout

\begin_layout Itemize
lseek
\end_layout

\begin_layout Itemize
pseek
\end_layout

\begin_layout Itemize
option_enum
\end_layout

\begin_layout Standard
all of which are pretty similar to their LibDsk namesakes.
 There are also the following properties:
\end_layout

\begin_layout Itemize
comment 
\end_layout

\begin_layout Itemize
option 
\end_layout

\begin_layout Itemize
retries 
\end_layout

\begin_layout Itemize
drvname 
\end_layout

\begin_layout Itemize
drvdesc 
\end_layout

\begin_layout Itemize
compname 
\end_layout

\begin_layout Itemize
compdesc 
\end_layout

\begin_layout Subsubsection
IReporter
\end_layout

\begin_layout Standard
IReporter is used for the LibDsk message callback.
 It is an interface that should be implemented by an object in your program.
 Set the library's "reporter" property to your object; then its report()
 and endreport() methods will be called.
\end_layout

\begin_layout Section
LibDsk RPC system
\end_layout

\begin_layout Standard
The LibDsk RPC system is designed to make disc drives on remote computers
 transparently available to LibDsk applications.
 It operates on a client/server basis; LibDsk contains a driver (called
 'remote') that can act as a client, and it can be used to implement a server.
\end_layout

\begin_layout Standard
The on-the-wire protocol is described in protocol.txt in the documentation
 directory.
\end_layout

\begin_layout Subsection
The 'serial' driver
\end_layout

\begin_layout Standard
This is designed for using LibDsk over a serial connection - say from a
 3.5
\begin_inset Quotes erd
\end_inset

 computer to a 5.25
\begin_inset Quotes erd
\end_inset

 computer.
 The filename specification to use at the client end is:
\end_layout

\begin_layout LyX-Code
serial:
\emph on
port
\emph default
,
\emph on
baud
\emph default
,
\emph on
remotename
\emph default
{,
\emph on
remotetype
\emph default
{,
\emph on
remotecompress
\emph default
}}
\end_layout

\begin_layout Standard
for example:
\end_layout

\begin_layout LyX-Code
serial:/dev/ttyS0,9600+crtscts,A:
\end_layout

\begin_layout Standard
The various parts of this filename specification are:
\end_layout

\begin_layout Description
port The local serial port to use.
\end_layout

\begin_deeper
\begin_layout Itemize
Under Linux, this is the name of a serial port (eg /dev/ttyS0).
\end_layout

\begin_layout Itemize
Under Windows, this is likewise the name of a serial port (eg COM1:).
\end_layout

\begin_layout Itemize
Under DOS, you need to have a FOSSIL serial port driver loaded; LibDsk was
 tested using ADF <http://ftp.iis.com.br/pub/simtelnet/msdos/fossil/adf_150.zip>
 (or do a web search for adf_150.zip).
 The port is then the number assigned by the FOSSIL driver (normally 0).
 Note also that ADF uses a single fixed baud rate, so you should make sure
 that the rate on the command line matches the rate that was used when ADF
 was loaded.
\end_layout

\end_deeper
\begin_layout Description
baud The speed and handshaking options.
 LibDsk does not allow the number of bits, the parity or the count of stop
 bits to be changed; it insists on 8-bit communications with 1 stop bit
 and no parity.
 The speed is a number (300, 600, 1200 etc.) and the handshake option is
 
\begin_inset Quotes eld
\end_inset

+crtscts
\begin_inset Quotes erd
\end_inset

 (to use RTS/CTS handshaking) or 
\begin_inset Quotes eld
\end_inset

-crtscts
\begin_inset Quotes erd
\end_inset

 (not to).
 If neither handshake option is present, 
\begin_inset Quotes eld
\end_inset

+crtscts
\begin_inset Quotes erd
\end_inset

 is assumed.
\end_layout

\begin_layout Description
remotename The name of the file or drive on the remote computer.
\end_layout

\begin_layout Description
remotetype The type of the file/drive (
\begin_inset Quotes eld
\end_inset

dsk
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

floppy
\begin_inset Quotes erd
\end_inset

 etc.).
 
\end_layout

\begin_layout Description
remotecompress The compression to use on the remote computer.
 
\end_layout

\begin_layout Subsubsection
Servers for the serial driver
\end_layout

\begin_layout Standard
One of the sample utilities supplied with LibDsk is called serslave (serslave.exe
 under DOS / Windows).
 This is a server using the same serial protocol as above.
 
\end_layout

\begin_layout Standard
Launch serslave with the command:
\end_layout

\begin_layout LyX-Code
serslave 
\shape italic
port,baud
\shape default
 
\end_layout

\begin_layout Standard
for example:
\end_layout

\begin_layout LyX-Code
serslave COM1:,9600+crtscts
\end_layout

\begin_layout Standard
or in DOS (again, a FOSSIL driver is required):
\end_layout

\begin_layout LyX-Code
serslave 0,19200
\end_layout

\begin_layout Standard
I have written a similar server for CP/M systems, called AUXD.
 This is a separate download from the LibDsk web page.
\end_layout

\begin_layout Subsection
The 'fork' driver
\end_layout

\begin_layout Standard
The 'fork' driver is used (on any system which supports the fork() system
 call) to send LibDsk requests to a local program using pipes.
 This driver was written for testing purposes, but may come in handy as
 a poor man's plugin system.
 The filename specification is: 
\end_layout

\begin_layout LyX-Code
fork:
\emph on
program
\emph default
,
\emph on
remotename
\emph default
{,
\emph on
remotetype
\emph default
{,
\emph on
remotecompress
\emph default
}}
\end_layout

\begin_layout Standard
for example:
\end_layout

\begin_layout LyX-Code
fork:./dskslave,a.dqk,dsk,sq
\end_layout

\begin_layout Standard
The various parts of this filename specification are:
\end_layout

\begin_layout Description
program The name of the program to use; execlp() is used to launch it, so
 if no path is given the user's PATH will be searched.
 The program must take LibDsk calls from its standard input and send results
 to its standard output.
\end_layout

\begin_layout Description
remotename The name of the file or drive.
\end_layout

\begin_layout Description
remotetype The type of the file/drive (
\begin_inset Quotes eld
\end_inset

dsk
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

floppy
\begin_inset Quotes erd
\end_inset

 etc.).
 
\end_layout

\begin_layout Description
remotecompress The compression to use.
 
\end_layout

\begin_layout Standard
An example of a server for this protocol is the example 'forkslave' program;
 this is a very simple wrapper around dsk_rpc_server() which reads RPC packets
 from its standard input and writes them to its standard output.
\end_layout

\begin_layout Section
Writing new drivers
\end_layout

\begin_layout Standard
The interface between LibDsk and its drivers is defined by the DRV_CLASS
 structure.
 To add a new driver, you create a new DRV_CLASS structure and add it to
 various files.
\end_layout

\begin_layout Standard
There are two methods of writing a driver.
 One is to provide all the functions yourself.
 The other is to write a driver using LDBS as its internal storage format;
 in that case, you need only provide dc_open(), dc_creat() and dc_close().
 The latter technique is particularly suited to formats that can't be rewritten
 in place (so you have to parse the whole file on open and rewrite the whole
 file on close anyway), and is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:LDBSdrivers"

\end_inset

.
\end_layout

\begin_layout Standard
Assuming you want to create a full driver that rewrites in-place, proceed
 as follows:
\end_layout

\begin_layout Subsection
The driver header 
\end_layout

\begin_layout Standard
Firstly, create a header for this driver, basing it on (for example) 
\family typewriter
lib/drvposix.h
\family default
.
 The first thing in the header (after the LGPL banner) is: 
\end_layout

\begin_layout LyX-Code
typedef struct 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    DSK_DRIVER px_super; 
\end_layout

\begin_layout LyX-Code
    FILE *px_fp; 
\end_layout

\begin_layout LyX-Code
    int px_readonly;
\end_layout

\begin_layout LyX-Code
    long px_filesize;
\end_layout

\begin_layout LyX-Code
} POSIX_DSK_DRIVER;
\end_layout

\begin_layout Standard
This is where you define any variables that your driver needs to store for
 each disc image.
 In the case of the 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 driver, this consists of a FILE pointer to access the underlying disc file,
 a 
\begin_inset Quotes eld
\end_inset

readonly
\begin_inset Quotes erd
\end_inset

 flag, and the current size of the drive image file.
 The first member of this structure must be of type DSK_DRIVER.
\end_layout

\begin_layout Standard
The rest of this header consists of function prototypes, which I will come
 back to later.
\end_layout

\begin_layout Subsection
The driver source file
\end_layout

\begin_layout Standard
Secondly, create a .c file for your driver.
 Again, it's probably easiest to base this on lib/drvposix.c.
 At the start of this file, create a DRV_CLASS structure, such as:
\end_layout

\begin_layout LyX-Code
DRV_CLASS dc_posix = 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    sizeof(POSIX_DSK_DRIVER), 
\end_layout

\begin_layout LyX-Code
    NULL,
\end_layout

\begin_layout LyX-Code
    "raw
\backslash
0rawalt
\backslash
0", 
\end_layout

\begin_layout LyX-Code
    "Raw file driver", 
\end_layout

\begin_layout LyX-Code
    posix_open, 
\end_layout

\begin_layout LyX-Code
    posix_creat, 
\end_layout

\begin_layout LyX-Code
    posix_close 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout Standard
The first four entries in this structure are: 
\end_layout

\begin_layout Itemize
The size of your driver's instance data; 
\end_layout

\begin_layout Itemize
The driver's superclass.
 This should be left as NULL.
\end_layout

\begin_layout Itemize
Possible names for the driver (each will be matched against the name passed
 to 
\family typewriter
dsk_open()
\family default
 / 
\family typewriter
dsk_creat()
\family default
 ).
 Each possible name, including the last, must be followed by 
\backslash
0.
\end_layout

\begin_layout Itemize
The driver's description string.
 
\end_layout

\begin_layout Standard
The remainder of the structure is composed of function pointers; the types
 of these are given in drv.h.
 At the very least, you will need to provide the first three pointers (*_open,
 *_creat and *_close); to make the driver vaguely useful, you will also
 need to implement some of the others.
\end_layout

\begin_layout Standard
Once you have created this structure, edit: 
\end_layout

\begin_layout Itemize
drivers.h.
 Add a declaration for your DRV_CLASS structure, such as 
\end_layout

\begin_layout LyX-Code
extern DRV_CLASS dc_myformat; 
\end_layout

\begin_layout Itemize
drivers.inc.
 Insert a reference to your structure (eg: 
\begin_inset Quotes eld
\end_inset


\family typewriter
&dc_myformat,
\family default

\begin_inset Quotes erd
\end_inset

) in the list.
 Note that order is important; the comments in drivers.inc describe how to
 decide where things go.
\end_layout

\begin_layout Standard
Edit 
\begin_inset Quotes eld
\end_inset

lib/Makefile.am
\begin_inset Quotes erd
\end_inset

.
 Near the top of this file is a list of drivers and their header files;
 just add your .c and .h to this list.
\end_layout

\begin_layout Standard
If your driver depends on certain system headers (as all the floppy drivers
 do) then you will need to add checks for these to 
\begin_inset Quotes eld
\end_inset

configure.in
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

lib/drvi.h
\begin_inset Quotes erd
\end_inset

; then run 
\begin_inset Quotes eld
\end_inset

autoconf
\begin_inset Quotes erd
\end_inset

 to rebuild the configure script.
\end_layout

\begin_layout Standard
The function pointers in the DRV_CLASS structure are described in drv.h.
 The first parameter to all of them (
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

) is declared as a pointer to DSK_DRIVER.
 In fact, it is a pointer to the first member of your instance data structure.
 Just cast the pointer to the correct type:
\end_layout

\begin_layout LyX-Code
/* Sanity check: Is this meant for our driver? */ 
\end_layout

\begin_layout LyX-Code
if (self->dr_class != &dc_posix) return DSK_ERR_BADPTR; 
\end_layout

\begin_layout LyX-Code
pxself = (POSIX_DSK_DRIVER *)self;
\end_layout

\begin_layout Standard
and you're in business.
\end_layout

\begin_layout Subsection
Driver functions
\end_layout

\begin_layout Subsubsection
dc_open
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_open )(DSK_PDRIVER self, const char *filename)
\end_layout

\begin_layout Standard
Attempt to open a disc image.
 Entered with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 points to the instance data for this disc image (see above); it will have
 been initialised to zeroes using memset().
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 is the name of the image to open.
 
\end_layout

\begin_layout Standard
Return: 
\end_layout

\begin_layout Description
DSK_ERR_OK: The driver has successfully opened the image.
 
\end_layout

\begin_layout Description
DSK_ERR_NOTME: The driver cannot handle this image.
 Other drivers should be allowed to try to use it.
 
\end_layout

\begin_layout Description
other: The driver cannot handle this image.
 No other drivers should be tried (eg: the image was recognised by this
 driver, but is corrupt).
\end_layout

\begin_layout Standard
If the file has a comment, record it here using dsk_set_comment().
\end_layout

\begin_layout Subsubsection
dc_creat
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_creat)(DSK_PDRIVER self, const char *filename)
\end_layout

\begin_layout Standard
Attempt to create a new disc image.
 For the 
\begin_inset Quotes eld
\end_inset

floppy
\begin_inset Quotes erd
\end_inset

 drivers, behaves exactly as dc_open.
 Parameters and results are the same as for dc_open, except that DSK_ERR_NOTME
 is treated like any other error.
\end_layout

\begin_layout Subsubsection
dc_close
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_close)(DSK_PDRIVER self)
\end_layout

\begin_layout Standard
Close the disc image.
 This will be the last call your driver will receive for a given disc image
 file, and it should free any resources it is using.
 Whether it returns DSK_ERR_OK or an error, this disc image will not be
 used again.
\end_layout

\begin_layout Subsubsection
dc_read 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_read)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, dsk_psect_t sector)
\end_layout

\begin_layout Standard
Read a sector.
 Note that sector addresses passed to drivers are 
\emph on
always
\emph default
 in C/H/S format.
 This function has the same parameters and return values as dsk_pread().
 
\end_layout

\begin_layout Standard
You don't need to check the RECMODE_COMPLEMENT flag in the geometry structure
 (this applies to all read and write functions).
 If the flag is set, the LibDsk core will complement the results from the
 driver before returning them to the caller.
 Similarly, any buffer passed for a write will already be complemented if
 appropriate.
\end_layout

\begin_layout Subsubsection
dc_write 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_write)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const
 void *buf, dsk_pcyl_t cylinder, dsk_phead_t head, dsk_psect_t sector)
\end_layout

\begin_layout Standard
Write a sector.
 This function has the same parameters and return values as dsk_pwrite().
 If your driver is read-only, leave this function pointer NULL.
\end_layout

\begin_layout Subsubsection
dc_format 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_format)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head, const DSK_FORMAT *format, unsigned char filler)
\end_layout

\begin_layout Standard
Format a track.
 This function has the same parameters and return values as dsk_pformat().
 If your driver cannot format tracks, leave this function pointer NULL.
\end_layout

\begin_layout Subsubsection
dc_getgeom
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_getgeom)(DSK_PDRIVER self, DSK_GEOMETRY *geom)
\end_layout

\begin_layout Standard
Get the disc geometry.
 Leave this function pointer as NULL unless either:
\end_layout

\begin_layout Enumerate
Your disc image does not allow a caller to use an arbitrary disc geometry.
 The drivers which currently do this are the Win32 one, because Windows
 NT decides on the geometry itself and doesn't let programs change it; and
 the MYZ80 and SIMH ones, which have a single fixed geometry.
\end_layout

\begin_layout Enumerate
Your disc image file contains enough information to populate a DSK_GEOMETRY
 completely.
 The rcpmfs and ydsk drivers do this.
 
\end_layout

\begin_layout Enumerate
You want to do an extended geometry probe including a call to the default
 one.
 The internal function dsk_defgetgeom() has been provided for this; it's
 the same as dsk_getgeom() but always uses the standard probe.
 The LDBS driver does this.
\end_layout

\begin_layout Standard
Returns DSK_ERR_OK if successful; DSK_ERR_NOTME or DSK_ERR_NOTIMPL to fall
 back to the standard LibDsk geometry probe; other values to indicate failure.
\end_layout

\begin_layout Subsubsection
dc_secid 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_secid)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head, DSK_FORMAT *result)
\end_layout

\begin_layout Standard
Read the ID of the next sector on a certain track/head, and put it in 
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

.
 Ideally you would simulate a rotating disc, so that the IDs are returned
 in the same order that they were written when the disc was formatted.
 This function is also used to test for discs in CPC format (which have
 oddly-numbered physical sectors); if the disc image can't support this
 (eg: the 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 or Win32 drivers) then leave the function pointer NULL.
 
\end_layout

\begin_layout Subsubsection
dc_xseek 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_xseek)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head);
\end_layout

\begin_layout Standard
Seek to a given cylinder / head.
 For disc images, just return DSK_ERR_OK if the cylinder/head are in range,
 or DSK_ERR_SEEKFAIL otherwise.
 For a floppy driver, only implement this function if your FDC can perform
 a seek by itself.
\end_layout

\begin_layout Subsubsection
dc_xread, dc_xwrite 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_xread)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, dsk_pcyl_t cyl_expected, dsk_phead_t
 head_expected, dsk_psect_t sector, size_t bytes_to_write, int *deleted);
 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_xwrite)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, const
 void *buf, dsk_pcyl_t cylinder, dsk_phead_t head, dsk_pcyl_t cyl_expected,
 dsk_phead_t head_expected, dsk_psect_t sector, size_t bytes_to_read, int
 *deleted);
\end_layout

\begin_layout Standard
Read / write sector whose ID may not match its position on disc, or which
 is marked as deleted.
 Only implement this if your disc image emulates sector IDs or your floppy
 driver exposes this level of functionality.
 Currently it is implemented in the Linux, NTWDM and CPCEMU drivers, plus
 those using LDBS as their internal storage (LDBS itself, DSK, EDSK, ApriDisk,
 CFI, JV3, CopyQM, QRST, Teledisk).
\end_layout

\begin_layout Subsubsection
dc_status 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_status)(DSK_PDRIVER self, const DSK_GEOMETRY &geom, dsk_phead_t
 head, unsigned char *result); 
\end_layout

\begin_layout Standard
Return the drive status (see dsk_drive_status() for the bits to return).
 
\begin_inset Quotes eld
\end_inset

*result
\begin_inset Quotes erd
\end_inset

 will contain the value calculated by the default implementation; for most
 image file drivers, all you have to do is set the read-only bit if appropriate.
\end_layout

\begin_layout Subsubsection
dc_tread 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_tread)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head);
\end_layout

\begin_layout Standard
Read a track.
 You need only implement this if your floppy driver exposes the relevant
 functionality; if you don't, the library will use multiple calls to dc_read()
 instead.
 This function has the same parameters and return values as dsk_ptread().
\end_layout

\begin_layout Subsubsection
dc_xtread
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_xread)(DSK_PDRIVER self, const DSK_GEOMETRY *geom, void *buf,
 dsk_pcyl_t cylinder, dsk_phead_t head, dsk_pcyl_t cyl_expected, dsk_phead_t
 head_expected);
\end_layout

\begin_layout Standard
Read a track, with extended sector matching (sector headers on disc differ
 from physical location).
 This function has the same parameters and return values as dsk_xtread().
 As with dc_tread(), you need only implement this function if your floppy
 driver has a special READ TRACK command.
\end_layout

\begin_layout Subsubsection
dc_option_enum
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_option_enum)(DSK_DRIVER *self, int idx, char **optname);
\end_layout

\begin_layout Standard
List numerical options which your driver supports.
 If your driver does not support any, you need not implement this.
\end_layout

\begin_layout Subsubsection
dc_option_set, dc_option_get
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_option_set)(DSK_DRIVER *self, const char *optname, int value);
 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_option_get)(DSK_DRIVER *self, const char *optname, int *value);
\end_layout

\begin_layout Standard
Get or set the value of a numerical option.
 Again, if your driver has no numerical options, this need not be implemented.
 
\end_layout

\begin_layout Standard
Note that numerical options can 'belong' either to a driver or to the LibDsk
 core, with the driver taking priority.
 For example:
\end_layout

\begin_layout Itemize
If LibDsk accesses a FAT-format disc image using the 'dsk' driver, neither
 LibDsk nor the driver will support the FS:CP/M:BSH option.
\end_layout

\begin_layout Itemize
If LibDsk accesses a CP/M-format disc image using the 'dsk' driver, dsk_get_geom
etry() will detect the CP/M filesystem.
 Since the driver does not support the FS:CP/M:BSH option, it will be handled
 by the LibDsk core.
\end_layout

\begin_layout Itemize
If LibDsk accesses a CP/M-format disc image using the 'ydsk' driver, the
 driver does support the FS:CP/M:BSH option and so it will be handled by
 the driver.
\end_layout

\begin_layout Standard
It is possible for a driver to rely on the option support in the LibDsk
 core rather than implement its own.
 This means a lot less code needs to be written; but it does not allow any
 validation to be performed on the values an option can hold, nor does it
 notify the driver when the value of an option is changed.
 Currently this system is used by the myz80 driver.
\end_layout

\begin_layout Standard
To use this system, create the variables you require with dsk_isetoption:
\end_layout

\begin_layout LyX-Code
dsk_err_t dsk_isetoption(DSK_DRIVER *self, const char *optname, int value,
 int create);
\end_layout

\begin_layout Standard
The first three parameters are the same as for dsk_set_option().
 The last should be set to 1 to create the new variable, or 0 to return
 DSK_ERR_BADOPT if the variable is not present.
\end_layout

\begin_layout Standard
To read a value back, use dsk_get_option() as normal.
\end_layout

\begin_layout Subsubsection
dc_trackids
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_trackids)(DSK_DRIVER *self,  const DSK_GEOMETRY *geom, dsk_pcyl_t
 cylinder, dsk_phead_t head, dsk_psect_t *count, DSK_FORMAT **result);
\end_layout

\begin_layout Standard
Read the IDs of all sectors on the specified track, preferably in the correct
 order and starting at the index hole.
 If you leave this function pointer as NULL, LibDsk will use a default implement
ation.
\end_layout

\begin_layout Subsubsection
dc_rtread
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_rtread)(DSK_DRIVER *self, const DSK_GEOMETRY *geom, void
 *buf, dsk_pcyl_t cylinder,  dsk_phead_t head, int reserved);
\end_layout

\begin_layout Standard
For future expansion.
 Leave this function pointer as NULL.
\end_layout

\begin_layout Subsubsection
dc_to_ldbs
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_to_ldbs)(DSK_DRIVER *self, struct ldbs **result, DSK_GEOMETRY
 *geom);
\end_layout

\begin_layout Standard
Export the current disk image file as an LDBS blockstore.
 If this driver is not for a disk image file, there's no need to implement
 this function.
\end_layout

\begin_layout Subsubsection
dc_from_ldbs
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_from_ldbs)(DSK_DRIVER *self, struct ldbs *source, DSK_GEOMETRY
 *geom);
\end_layout

\begin_layout Standard
Replace the entire contents of this disk image with the provided LDBS blockstore.
 If this driver is not for a disk image file, there's no need to implement
 this function.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:LDBSdrivers"

\end_inset

Writing new drivers (derived from LDBS)
\end_layout

\begin_layout Standard
The technique when creating an LDBS-based driver is similar to a standalone
 driver, with a few important differences.
 A good example file to look at for this is the QRST driver.
\end_layout

\begin_layout Standard
An LDBS-based driver will need to make extensive use of the functions in
 
\family typewriter
lib/ldbs.h
\family default
.
 Currently the best documentation for these functions is in the comments
 of 
\family typewriter
ldbs.h
\family default
 itself.
 
\end_layout

\begin_layout Subsection
The driver header 
\end_layout

\begin_layout Standard
As for a standalone driver, create a header, basing it on (for example)
 
\family typewriter
lib/drvqrst.h
\family default
.
 The first thing in the header (after the LGPL banner) is: 
\end_layout

\begin_layout LyX-Code
typedef struct 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    LDBSDISK_DSK_DRIVER qrst_super;
\end_layout

\begin_layout LyX-Code
    char *qrst_filename;
\end_layout

\begin_layout LyX-Code
    /* The following variables hold state when saving, and are only
\end_layout

\begin_layout LyX-Code
     * used within qrst_close() */         
\end_layout

\begin_layout LyX-Code
    size_t qrst_tracklen;         
\end_layout

\begin_layout LyX-Code
    unsigned long qrst_bias;         
\end_layout

\begin_layout LyX-Code
    unsigned long qrst_checksum; 
\end_layout

\begin_layout LyX-Code
} QRST_DSK_DRIVER;
\end_layout

\begin_layout Standard
The major difference here is that the first member of the structure is a
 
\family typewriter
LDBSDISK_DSK_DRIVER
\family default
 rather than a plain 
\family typewriter
DSK_DRIVER
\family default
.
\end_layout

\begin_layout Subsection
The driver source file
\end_layout

\begin_layout Standard
Secondly, create a .c file for your driver.
 Again, it's probably easiest to base this on 
\family typewriter
lib/drvqrst.
\family default
c.
 At the start of this file, create a DRV_CLASS structure, such as:
\end_layout

\begin_layout LyX-Code
DRV_CLASS dc_qrst = 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    sizeof(QRST_DSK_DRIVER), 
\end_layout

\begin_layout LyX-Code
    &dc_ldbsdisk,
\end_layout

\begin_layout LyX-Code
    "QRST", 
\end_layout

\begin_layout LyX-Code
    "Quick Release Sector Transfer", 
\end_layout

\begin_layout LyX-Code
    qrst_open, 
\end_layout

\begin_layout LyX-Code
    qrst_creat, 
\end_layout

\begin_layout LyX-Code
    qrst_close 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout Standard
The first four entries in this structure are: 
\end_layout

\begin_layout Itemize
The size of your driver's instance data; 
\end_layout

\begin_layout Itemize
The driver's superclass.
 This needs to be set to 
\family typewriter
&dc_ldbsdisk
\family default
, rather than NULL as it would be in a standalone driver.
\end_layout

\begin_layout Itemize
The driver's name (as passed to 
\family typewriter
dsk_open()
\family default
 / 
\family typewriter
dsk_creat()
\family default
 ) 
\end_layout

\begin_layout Itemize
The driver's description string.
 
\end_layout

\begin_layout Standard
The remainder of the structure is composed of function pointers, but you
 should only need to provide the first three pointers (*_open, *_creat and
 *_close).
\end_layout

\begin_layout Standard
Once you have created this structure, edit: 
\end_layout

\begin_layout Itemize
drivers.h.
 Add a declaration for your DRV_CLASS structure, such as 
\end_layout

\begin_layout LyX-Code
extern DRV_CLASS dc_myformat; 
\end_layout

\begin_layout Itemize
drivers.inc.
 Insert a reference to your structure (eg: 
\begin_inset Quotes eld
\end_inset


\family typewriter
&dc_myformat,
\family default

\begin_inset Quotes erd
\end_inset

) in the list.
 Note that order is important; the comments in drivers.inc describe how to
 decide where things go.
\end_layout

\begin_layout Standard
Edit 
\begin_inset Quotes eld
\end_inset

lib/Makefile.am
\begin_inset Quotes erd
\end_inset

.
 Near the top of this file is a list of drivers and their header files;
 just add your .c and .h to this list.
\end_layout

\begin_layout Standard
If your driver depends on certain system headers (as all the floppy drivers
 do) then you will need to add checks for these to 
\begin_inset Quotes eld
\end_inset

configure.in
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

lib/drvi.h
\begin_inset Quotes erd
\end_inset

; then run 
\begin_inset Quotes eld
\end_inset

autoconf
\begin_inset Quotes erd
\end_inset

 to rebuild the configure script.
\end_layout

\begin_layout Standard
The function pointers in the DRV_CLASS structure are described in drv.h.
 The first parameter to all of them (
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

) is declared as a pointer to DSK_DRIVER.
 In fact, it is a pointer to the first member of your instance data structure.
 Just cast the pointer to the correct type:
\end_layout

\begin_layout LyX-Code
/* Sanity check: Is this meant for our driver? */ 
\end_layout

\begin_layout LyX-Code
if (self->dr_class != &dc_qrst) return DSK_ERR_BADPTR; 
\end_layout

\begin_layout LyX-Code
qrstself = (QRST_DSK_DRIVER *)self;
\end_layout

\begin_layout Standard
and you're in business.
\end_layout

\begin_layout Subsection
Driver functions
\end_layout

\begin_layout Subsubsection
dc_open
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_open )(DSK_PDRIVER self, const char *filename)
\end_layout

\begin_layout Standard
Open a disc image and load it into an LDBS blockstore.
 Entered with: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 points to the instance data for this disc image (see above); it will have
 been initialised to zeroes using memset().
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 is the name of the image to open.
 
\end_layout

\begin_layout Standard
Return: 
\end_layout

\begin_layout Description
DSK_ERR_OK: The driver has successfully opened the image.
 
\end_layout

\begin_layout Description
DSK_ERR_NOTME: The driver cannot handle this image.
 Other drivers should be allowed to try to use it.
 
\end_layout

\begin_layout Description
other: The driver cannot handle this image.
 No other drivers should be tried (eg: the image was recognised by this
 driver, but is corrupt).
\end_layout

\begin_layout Standard
Once you have established that your driver can open and parse the image
 it was passed, it should initialise the LDBS blockstore in the superclass,
 using 
\family typewriter
ldbs_new()
\family default
:
\end_layout

\begin_layout LyX-Code
dsk_err_t ldbs_new(PLDBS *result, const char *filename, const char type[4]);
\end_layout

\begin_layout Standard
In this case, the first parameter should point to the blockstore in the
 superclass.
 The other two should be NULL and LDBS_DSK_TYPE respectively:
\end_layout

\begin_layout LyX-Code
ldbs_new(&qrself->qrst_super.ld_store, NULL, LDBS_DSK_TYPE);
\end_layout

\begin_layout Standard
You then need to read in the entire disc image and save it in the blockstore
 using LDBS functions:
\end_layout

\begin_layout Itemize
For each track, use 
\family typewriter
ldbs_trackhead_alloc()
\family default
 to create a track header structure.
\end_layout

\begin_layout Itemize
For each sector in that track, use 
\family typewriter
ldbs_encode_secid()
\family default
 to generate its block ID, then 
\family typewriter
ldbs_putblock()
\family default
 to add it to the store.
 Record the block ID in that sector's entry in the track header.
\end_layout

\begin_layout Itemize
Once all the sectors have been added, use 
\family typewriter
ldbs_put_trackhead()
\family default
 to add the completed track header.
 
\end_layout

\begin_layout Standard
If the file has a comment, record it using 
\family typewriter
ldbs_put_comment() 
\family default
rather than
\family typewriter
 dsk_set_comment().

\family default
 If your disc image has a fixed geometry you should convert it to a 
\family typewriter
DSK_GEOMETRY
\family default
 structure and record it with 
\family typewriter
ldbs_put_geometry()
\family default
.
 A few disc image formats contain a CP/M Disk Parameter block; if yours
 is one you should add that with 
\family typewriter
ldbs_put_dpb()
\family default
.
\end_layout

\begin_layout Standard
Once the blockstore is completely populated, end with 
\end_layout

\begin_layout LyX-Code
return ldbsdisk_attach(self); 
\end_layout

\begin_layout Subsubsection
dc_creat
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_creat)(DSK_PDRIVER self, const char *filename)
\end_layout

\begin_layout Standard
This should check that the target file can be created, and keep hold of
 either its filename or file handle.
 It should then behave as 'open', except that you don't do anything with
 the blockstore created by 
\family typewriter
ldbs_new()
\family default
 before calling 
\family typewriter
ldbsdisk_attach().

\family default
 
\end_layout

\begin_layout Subsubsection
dc_close
\end_layout

\begin_layout LyX-Code
dsk_err_t (*dc_close)(DSK_PDRIVER self)
\end_layout

\begin_layout Standard
Close the disc image.
 If it has been changed, you need to write out the contents of the blockstore
 to a new file, overwriting anything that was there already.
\end_layout

\begin_layout Standard
The first thing to do (after basic sanity checks) is to call 
\family typewriter
ldbsdisk_detach()
\family default
 to ensure all pending buffers have been written to the blockstore.
 The next is to check if any changes need to be written back; if 
\family typewriter
self->dr_dirty
\family default
 is zero, there's nothing to write back, so you can just close the blockstore
 and return.
\end_layout

\begin_layout LyX-Code
return ldbs_close(&qrself->qrst_super.ld_store);
\end_layout

\begin_layout Standard
Assuming that changes do need to be written back, you now need to reverse
 the conversion done by your 'open' method, and write the blockstore out
 in the your disc image format.
 Some functions which may be helpful here are:
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_max_cyl_head()
\family default
 will return the number of cylinders and heads necessary to contain this
 disc image.
 For example, a 720k DOS disc image would return 80 cylinders, 2 heads.
 
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_get_stats()
\family default
 will analyse the blockstore and return the maximum and minimum values for
 cylinder, head, sector, sectors per track and sector size.
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_all_tracks()
\family default
 will iterate over all tracks in the blockstore and, for each track, call
 a callback function you provide.
 It can return the tracks in SIDES_ALT, SIDES_OUTOUT or SIDES_OUTBACK order;
 if you want to process them in a different order you'll need to write your
 own iteration function.
 In that case, use 
\family typewriter
ldbs_max_cyl_head()
\family default
 to get the range, and then 
\family typewriter
ldbs_get_trackhead()
\family default
 for each track you want to process.
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_all_sectors()
\family default
 works on the same principle, but the callback is run for each sector in
 each track.
 Note that sectors will be returned in the order they are listed in the
 track header, which may well be different from their numerical order.
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_getblock()
\family default
 will load a sector using the block ID given for it in the track header.
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_get_comment()
\family default
 will return the comment (if any).
 Similarly 
\family typewriter
ldbs_get_dpb()
\family default
 retrieves the CP/M DPB (if one was written) and 
\family typewriter
ldbs_get_geom()
\family default
 returns the DSK_GEOMETRY last used to format a track.
 Note that the geometry recorded is advisory; if it conflicts with the values
 returned by 
\family typewriter
ldbs_get_stats()
\family default
, the values returned by 
\family typewriter
ldbs_get_stats()
\family default
 are going to be the accurate ones.
\end_layout

\begin_layout Itemize

\family typewriter
ldbs_load_track()
\family default
 will return a memory buffer containing the data from all the sectors in
 a particular track, in sector ID order.
\end_layout

\begin_layout Standard

\family typewriter
*_close()
\family default
 will be the last call your driver will receive for a given disc image file,
 and it should free any resources it is using.
 Whether it returns DSK_ERR_OK or an error, this disc image will not be
 used again.
\end_layout

\begin_layout Section
Adding new compression methods
\end_layout

\begin_layout Standard
Adding a new compression method is very similar to adding a driver, though
 you only have to implement four functions.
\end_layout

\begin_layout Standard
To add a new driver, you create a new COMPRESS_CLASS structure and add it
 to various files.
\end_layout

\begin_layout Subsection
Driver header 
\end_layout

\begin_layout Standard
This is done as for disc drivers.
 If you don't need any extra variables (for example, gzip and bzip2 compression
 don't) then you don't have to declare a new structure type - see lib/compgz.h
 for an example.
\end_layout

\begin_layout Subsection
Driver implementation 
\end_layout

\begin_layout Standard
Secondly, create a .c file for your driver.
 It's probably easiest to base this on lib/compgz.c.
 At the start of this file, create a COMPRESS_CLASS structure, such as:
\end_layout

\begin_layout LyX-Code
COMPRESS_CLASS cc_gz = 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    sizeof(COMPRESS_DATA), 
\end_layout

\begin_layout LyX-Code
    "gz", 
\end_layout

\begin_layout LyX-Code
    "Gzip (deflate compression)", 
\end_layout

\begin_layout LyX-Code
    gz_open, /* open */ 
\end_layout

\begin_layout LyX-Code
    gz_creat, /* create new */ 
\end_layout

\begin_layout LyX-Code
    gz_commit, /* commit */ 
\end_layout

\begin_layout LyX-Code
    gz_abort /* abort */ 
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
The first three entries in this structure are: 
\end_layout

\begin_layout Itemize
The size of your driver's instance data.
 The GZip driver has no instance data and so just uses COMPRESS_DATA.
 If it had extra data these would be in a struct called GZ_COMPRESS_DATA,
 so the size here would be sizeof(GZ_COMPRESS_DATA).
 
\end_layout

\begin_layout Itemize
The driver's name (as passed to dsk_open() / dsk_creat() ) 
\end_layout

\begin_layout Itemize
The driver's description string.
 
\end_layout

\begin_layout Standard
The remainder of the structure is composed of function pointers.
 The types of these are given in drv.h.
 You must implement all four.
\end_layout

\begin_layout Standard
Once you have created this structure, edit: 
\end_layout

\begin_layout Itemize
comp.h.
 Include your header.
 
\end_layout

\begin_layout Itemize
compress.inc.
 Insert a reference to your structure (eg: 
\begin_inset Quotes eld
\end_inset

&cc_myzip,
\begin_inset Quotes erd
\end_inset

) in the list.
 Note that order is important.
\end_layout

\begin_layout Standard
Edit 
\begin_inset Quotes eld
\end_inset

lib/Makefile.am
\begin_inset Quotes erd
\end_inset

.
 At the bottom of this file is a list of drivers and their header files;
 just add your .c and .h to this list.
\end_layout

\begin_layout Standard
If your driver depends on certain system headers (eg, the gzip one depends
 on zlib.h) then you will need to add checks for these to 
\begin_inset Quotes eld
\end_inset

configure.in
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

lib/compi.h
\begin_inset Quotes erd
\end_inset

; then run 
\begin_inset Quotes eld
\end_inset

autoconf
\begin_inset Quotes erd
\end_inset

 to rebuild the configure script.
\end_layout

\begin_layout Standard
The function pointers in the COMPRESS_CLASS structure are described in lib/compr
ess.h.
 The first parameter to all of them (
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

) is declared as a pointer to COMPRESS_DATA.
 In fact, it is a pointer to the first member of your instance data structure.
 Just cast the pointer to the correct type:
\end_layout

\begin_layout LyX-Code
/* Sanity check: Is this meant for our driver? */ 
\end_layout

\begin_layout LyX-Code
if (self->cd_class != &cc_sq) return DSK_ERR_BADPTR; 
\end_layout

\begin_layout LyX-Code
sqself = (SQ_COMPRESS_DATA *)self;
\end_layout

\begin_layout Standard
and you're in business.
\end_layout

\begin_layout Subsection
Compression functions
\end_layout

\begin_layout Subsubsection
cc_open 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*cc_open )(COMPRESS_DATA *self)
\end_layout

\begin_layout Standard
Attempt to decompress a compressed file.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 points to the instance data for this disc image.
 
\end_layout

\begin_layout Itemize
self->cd_cfilename is the filename of the file to decompress.
\end_layout

\begin_layout Standard
Return: 
\end_layout

\begin_layout Description
DSK_ERR_OK: The file has been decompressed.
 
\end_layout

\begin_layout Description
DSK_ERR_NOTME: The file is not compressed using this driver's method.
 
\end_layout

\begin_layout Description
other: The file does belong to this driver, but it is corrupt or some other
 error occurred.
\end_layout

\begin_layout Standard
Two helper functions may be useful when you are writing cc_open:
\end_layout

\begin_layout LyX-Code
dsk_err_t comp_fopen(COMPRESS_DATA *self, FILE **pfp);
\end_layout

\begin_layout Standard
Open the the file whose name is given at 
\family typewriter
self->cd_cfilename
\family default
.
 If successful, 
\family typewriter
*pfp
\family default
 will be the opened stream.
 If not, it will be NULL.
 If the file can only be opened read-only, sets 
\family typewriter
self->cd_readonly
\family default
 to 1.
\end_layout

\begin_layout LyX-Code
dsk_err_t comp_mktemp(COMPRESS_DATA *self, FILE **pfp);
\end_layout

\begin_layout Standard
Create a temporary file and store its name at 
\family typewriter
self->cd_ufilename
\family default
.
 You should use this to create the file that you decompress into.
\end_layout

\begin_layout Subsubsection
cc_creat
\end_layout

\begin_layout LyX-Code
dsk_err_t (*cc_creat)(COMPRESS_DATA *cd)
\end_layout

\begin_layout Standard
Warn the compression engine that a disc image file is being created, and
 when closed it will be compressed.
 The filename is stored at 
\family typewriter
self->cd_cfilename
\family default
.
 Normally this just returns DSK_ERR_OK.
\end_layout

\begin_layout Subsubsection
cc_commit
\end_layout

\begin_layout LyX-Code
dsk_err_t (*cc_commit)(COMPRESS_DATA *cd)
\end_layout

\begin_layout Standard
Compress an uncompressed file.
 
\family typewriter
self->cd_ufilename
\family default
 is the name of the file to compress.
 
\family typewriter
self->cd_cfilename
\family default
 is the name of the output file.
\end_layout

\begin_layout Subsubsection
cc_abort 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*cc_abort)(COMPRESS_DATA *cd)
\end_layout

\begin_layout Standard
This is used if a file was decompressed and it's now being closed without
 having been changed.
 There is therefore no need to compress it again.
 This normally just returns DSK_ERR_OK.
\end_layout

\begin_layout Section
Adding new remote transports.
\end_layout

\begin_layout Standard
Adding a new remote transport is also very similar to adding a driver.
\end_layout

\begin_layout Standard
To add a new driver, you create a new REMOTE_CLASS structure and add it
 to various files.
\end_layout

\begin_layout Subsection
Driver header 
\end_layout

\begin_layout Standard
This is done as for disc drivers.
 Create a structure based on REMOTE_DATA to hold your class's data -- see
 lib/rpctios.h and lib/rpcfork.h for examples.
\end_layout

\begin_layout Subsection
Driver implementation 
\end_layout

\begin_layout Standard
Create a .c file for your driver.
 It's probably easiest to base this on lib/rpcfork.c.
 At the start of this file, create a REMOTE_CLASS structure, such as:
\end_layout

\begin_layout LyX-Code
REMOTE_CLASS rpc_fork = 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    sizeof(FORK_REMOTE_DATA), 
\end_layout

\begin_layout LyX-Code
    "fork", 
\end_layout

\begin_layout LyX-Code
    "UNIX client using fork", 
\end_layout

\begin_layout LyX-Code
    fork_open, /* open */ 
\end_layout

\begin_layout LyX-Code
    fork_close, /* close */ 
\end_layout

\begin_layout LyX-Code
    fork_call, /* perform RPC */ 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
The first three entries in this structure are: 
\end_layout

\begin_layout Itemize
The size of your driver's instance data -- sizeof(your_REMOTE_DATA) structure.
\end_layout

\begin_layout Itemize
The driver's name.
 If the filename passed to LibDsk begins with this name followed by a colon,
 then it's assumed to be using your driver.
 
\end_layout

\begin_layout Itemize
The driver's description string.
 
\end_layout

\begin_layout Standard
The remainder of the structure is composed of function pointers.
 The types of these are given in lib/remote.h.
 You must implement all three.
\end_layout

\begin_layout Standard
Once you have created this structure, edit: 
\end_layout

\begin_layout Itemize
lib/remall.h.
 Include your header.
 
\end_layout

\begin_layout Itemize
lib/remote.inc.
 Insert a reference to your structure (eg: 
\begin_inset Quotes eld
\end_inset

&rpc_fork,
\begin_inset Quotes erd
\end_inset

) in the list.
 The drivers will be tested in the order in which they appear in the file.
\end_layout

\begin_layout Standard
Edit 
\begin_inset Quotes eld
\end_inset

lib/Makefile.am
\begin_inset Quotes erd
\end_inset

.
 At the bottom of this file is a list of drivers and their header files;
 just add your .c and .h to this list.
\end_layout

\begin_layout Standard
If your driver depends on certain system headers (eg, the termios one depends
 on termios.h) then you will need to add checks for these to 
\begin_inset Quotes eld
\end_inset

configure.in
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

lib/drvi.h
\begin_inset Quotes erd
\end_inset

; then run 
\begin_inset Quotes eld
\end_inset

autoconf
\begin_inset Quotes erd
\end_inset

 to rebuild the configure script.
\end_layout

\begin_layout Standard
The function pointers in the REMOTE_CLASS structure are described in lib/compres
s.h.
 The first parameter to all of them (
\begin_inset Quotes eld
\end_inset

pDriver
\begin_inset Quotes erd
\end_inset

) is declared as DSK_PDRIVER; you can extract a pointer to your instance
 data using the dr_remote member like this:
\end_layout

\begin_layout LyX-Code
/* Sanity checks */ 
\end_layout

\begin_layout LyX-Code
self = (FORK_REMOTE_DATA *)pDriver->dr_remote;
\end_layout

\begin_layout LyX-Code
if (self == NULL || self->super.rd_class != &rpc_fork) 
\end_layout

\begin_layout LyX-Code
        return DSK_ERR_BADPTR; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Remote communication functions
\end_layout

\begin_layout Subsubsection
rc_open 
\end_layout

\begin_layout LyX-Code
dsk_err_t (*rc_open )(DSK_PDRIVER pDriver, const char *name, char *nameout)
\end_layout

\begin_layout Standard
Connect to a remote server.
 
\end_layout

\begin_layout Itemize
pDriver points to a DSK_DRIVER containing the pointer to your instance data.
\end_layout

\begin_layout Itemize
name is the filename as passed to LibDsk, starting with 
\begin_inset Quotes eld
\end_inset


\emph on
driver
\emph default
:
\begin_inset Quotes erd
\end_inset

 and containing any connection parameters needed.
 
\end_layout

\begin_layout Itemize
nameout is an output buffer with enough space to hold a string of the same
 length as the input filename.
 If you are returning DSK_ERR_OK, it must be set to the input filename minus
 any options this driver has used.
 For example, the 
\begin_inset Quotes eld
\end_inset

serial
\begin_inset Quotes erd
\end_inset

 driver, given a filename like 
\begin_inset Quotes eld
\end_inset

serial:/dev/ttyS1,2400-crtscts,example.ufi,raw
\begin_inset Quotes erd
\end_inset

 would extract its own options and return 
\begin_inset Quotes eld
\end_inset

example.ufi,raw
\begin_inset Quotes erd
\end_inset

 here.
 
\end_layout

\begin_layout Standard
Return: 
\end_layout

\begin_layout Description
DSK_ERR_OK: Connection established.
\end_layout

\begin_layout Description
DSK_ERR_NOTME: The filename passed is not recognised by this driver.
 
\end_layout

\begin_layout Description
other: An error such as out-of-memory occurred.
\end_layout

\begin_layout Subsubsection
rc_close
\end_layout

\begin_layout LyX-Code
dsk_err_t (*rc_close)(DSK_PDRIVER pDriver)
\end_layout

\begin_layout Standard
Close the connection to the remote server.
\end_layout

\begin_layout Subsubsection
rc_call
\end_layout

\begin_layout LyX-Code
dsk_err_t (*rc_call)(DSK_PDRIVER pDriver, unsigned char *input, int inp_len,
 unsigned char *output, int *out_len)
\end_layout

\begin_layout Standard
Perform a remote procedure call to the server.
 
\end_layout

\begin_layout Description
input is the packet LibDsk wants to send.
\end_layout

\begin_layout Description
inp_len is the number of bytes in the packet.
\end_layout

\begin_layout Description
output is a buffer for the result packet.
\end_layout

\begin_layout Description
*out_len (on entry) is the size of the result buffer.
\end_layout

\begin_layout Description
*out_len (on return) is the number of bytes that were populated in the result
 buffer.
\end_layout

\begin_layout Standard
In general, this call will wrap the input in whatever framing bytes are
 necessary (usually including the packet length, since packets do not contain
 their own length), send the packet over the wire, wait for a response,
 and unpack the response into 'output'.
 Return DSK_ERR_TIMEOUT if the connection timed out (the 'serial' driver
 waits 30 seconds) and DSK_ERR_ABORT if the user deliberately broke the
 connection.
\end_layout

\begin_layout Section
\start_of_appendix
\begin_inset CommandInset label
LatexCommand label
name "sec:copyqm"

\end_inset

The CopyQM File Format
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
This section describes the file format of files created by CopyQM.
 A lot of the information has been extracted by looking at hex-dumps of
 the files, so there might be some errors in the description.
 
\end_layout

\begin_layout Subsection
Header
\end_layout

\begin_layout Standard
The CopyQM files consist of a header, an optional comment (if indicated
 by the header) followed by the tracks of the image encoded with a run length
 encoding scheme.
 The header is 133 bytes long, see table.
 It always starts with {0x43, 0x51, 0x14 }, which can be used for auto-detection
 of the image.
 All numbers have little-endian byte ordering.
 When all bytes in the header are added together in a byte, the result should
 be zero.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="30" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Always 0x43 ('C')
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x01
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Always 0x51 ('Q')
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x02
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Always 0x14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x03
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sector size (from here to 0x1B inclusive is a DOS BPB)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sectors per cluster
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x06
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of reserved sectors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x08
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FAT copies
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x09
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of root directory entries
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total number of sectors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Media byte
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of sectors per FAT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of sectors per track
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of heads
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of hidden sectors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total sectors if > 65535 (should always be 0 on a floppy image)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x1c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description of media (e.g.
 
\begin_inset Quotes eld
\end_inset

720K Double-Sided
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x58
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type of image.
 0=DOS, 1=blind, 2=HFS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x59
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Density.
 0=DD, 1=HD, 2=ED
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x5a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of tracks used on image
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x5b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total number of tracks for image
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x5c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CRC for the used, unpacked tracks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Volume label (DOS/HFS)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Creation time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Creation date
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x6f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length of image comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x71
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of first sector - 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x74
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interleave.
 (0 for older versions of CopyQM)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Skew.
 Normally 0.
 Negative number for alt.
 sides
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Header checksum byte
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
CRC
\end_layout

\begin_layout Standard
The CRC is calculated for the unpacked data for all tracks that are used
 in the image.
 The CRC value is initialized with 0 and then updated using the CRC 32 polynomia
l 0x104C11DB7, bit reverse algorithm.
 Due to a feature in CopyQM (8 bit register as an index into a 1024 byte
 table) all bytes must have their top two bits removed before added to the
 CRC.
\end_layout

\begin_layout Subsection
Image comment
\end_layout

\begin_layout Standard
The image comment follows the header.
 It has a variable size found in the header.
 The image comment can contain 
\backslash
0-bytes.
\end_layout

\begin_layout Subsection
Image data
\end_layout

\begin_layout Standard
The image data is run length encoded.
 Each run is preceded by a 16-bit length.
 If the length is negative, the byte after the length is repeated 
\series bold
-length
\series default
 times.
 If the length is positive, it is followed by 
\series bold
length
\series default
 bytes of unencoded data.
 It seems like a new run of repeating or differing data is always started
 at each new track.
 Older versions of CopyQM always alternates between runs of differing data
 and repeating data, even if the length of one of them is zero.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec: dqk"

\end_inset

DQK Files 
\end_layout

\begin_layout Standard
A DQK file is a .DSK file compressed using Richard Greenlaw's Squeeze file
 format (originally from CP/M as SQ.COM, and later built in to NSWP.COM; versions
 also exist for DOS and UNIX).
 SQ was used in preference to more efficient compressors such as gzip because
 it can be readily decoded on 8-bit and 16-bit computers.
\end_layout

\begin_layout Standard
The original reason for DQK files was software distribution.
 A disc image of a 180k disc won't fit on a 180k disc, owing to various
 overheads.
 However, the compressed DQK version may fit onto such a disc, and leave
 room for a tool to write the DQK back out as well.
 
\end_layout

\begin_layout Standard
Such a tool has been included in the 
\begin_inset Quotes eld
\end_inset

dskwrite
\begin_inset Quotes erd
\end_inset

 directory in this distribution.
 It contains the following files:
\end_layout

\begin_layout Itemize
dskwrite.com: Program to write .DSK or .DQK files out to a real disc.
 The .COM file works on PCs, Amstrad PCWs and Sinclair Spectrum +3s.
 
\end_layout

\begin_layout Itemize
dskwrite.txt: Documentation for dskwrite.
 
\end_layout

\begin_layout Itemize
dskwrite.z80: Z80 source for the CP/M version.
 
\end_layout

\begin_layout Itemize
dskwrite.asm: 8086 source for the DOS version.
 
\end_layout

\begin_layout Itemize
dskwrsea.com: The dskwrite distribution file - a self-extracting archive.
 It will self-extract under CP/M or DOS.
\end_layout

\begin_layout Standard
Note that the files in the 
\begin_inset Quotes eld
\end_inset

dskwrite
\begin_inset Quotes erd
\end_inset

 directory are not GPLed or LGPLed.
 They are public domain.
 You may do whatsoever you please with them.
\end_layout

\begin_layout Standard
LibDsk has been given .DQK support (use the 
\begin_inset Quotes eld
\end_inset

dsk
\begin_inset Quotes erd
\end_inset

 driver with 
\begin_inset Quotes eld
\end_inset

sq
\begin_inset Quotes erd
\end_inset

 compression) so that .DQK files don't have to be created and compressed
 in a two-state process.
 
\end_layout

\begin_layout Section
LibDsk with cpmtools
\end_layout

\begin_layout Standard
cpmtools v1.9 and later <http://www.moria.de/~michael/cpmtools/> can be configured
 to use LibDsk for all disc access, thus allowing CP/M discs and emulator
 disc images to be read and written.
 
\end_layout

\begin_layout Standard
cpmtools v2.19+ allow a cpmtools disk definition to be associated with a
 LibDsk geometry, by adding a 
\begin_inset Quotes eld
\end_inset

libdsk:format
\begin_inset Quotes erd
\end_inset

 entry to the disk definition.
 For example, this entry uses 
\begin_inset Quotes eld
\end_inset

libdsk:format ibm1440
\begin_inset Quotes erd
\end_inset

 so that the disk image is accessed using the 'ibm1440' geometry rather
 than the default 'pcw1440'.
\end_layout

\begin_layout LyX-Code
diskdef cpm86-144feat
\end_layout

\begin_layout LyX-Code
  seclen 512
\end_layout

\begin_layout LyX-Code
  tracks 160
\end_layout

\begin_layout LyX-Code
  sectrk 18
\end_layout

\begin_layout LyX-Code
  blocksize 4096
\end_layout

\begin_layout LyX-Code
  maxdir 256
\end_layout

\begin_layout LyX-Code
  skew 1
\end_layout

\begin_layout LyX-Code
  boottrk 2
\end_layout

\begin_layout LyX-Code
  os 3
\end_layout

\begin_layout LyX-Code
  libdsk:format ibm1440
\end_layout

\begin_layout LyX-Code
end 
\end_layout

\begin_layout Standard
The myz80 and nanowasp drivers use a fixed disk format; here are diskdefs
 entries which can be used to read them:
\end_layout

\begin_layout LyX-Code
diskdef myz80
\end_layout

\begin_layout LyX-Code
  seclen 1024
\end_layout

\begin_layout LyX-Code
  tracks 64   
\end_layout

\begin_layout LyX-Code
  sectrk 128
\end_layout

\begin_layout LyX-Code
  blocksize 4096
\end_layout

\begin_layout LyX-Code
  maxdir 1024
\end_layout

\begin_layout LyX-Code
  skew 1
\end_layout

\begin_layout LyX-Code
  boottrk 0
\end_layout

\begin_layout LyX-Code
  os 3
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
diskdef nanowasp
\end_layout

\begin_layout LyX-Code
  seclen 512
\end_layout

\begin_layout LyX-Code
  tracks 80
\end_layout

\begin_layout LyX-Code
  sectrk 10
\end_layout

\begin_layout LyX-Code
  blocksize 2048
\end_layout

\begin_layout LyX-Code
  maxdir 128
\end_layout

\begin_layout LyX-Code
  skew 1
\end_layout

\begin_layout LyX-Code
  os 2.2
\end_layout

\begin_layout LyX-Code
end
\end_layout

\begin_layout Standard
In the old diskdefs format with one line per entry, these are:
\end_layout

\begin_layout LyX-Code
myz80    1024 64 128 4096 1024 1 0 3 
\end_layout

\begin_layout LyX-Code
microbee  512 80  10 2048 128  1 2 2.2
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
DSK / EDSK recording mode extension
\end_layout

\begin_layout Standard
This extension was proposed by me on the comp.sys.sinclair and comp.sys.amstrad.8bit
 newsgroups on 10 January 2004.
 It was subsequently released in ANNE 2.1.4 and added to the formal EDSK format
 definition at <http://andercheran.aiind.upv.es/~amstrad/docs/extdsk.html 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://andercheran.aiind.upv.es/~amstrad/docs/extdsk.html
\end_layout

\end_inset

>.
\end_layout

\begin_layout Standard
DSK/EDSK originate on the Amstrad CPC, which ordinarily writes all its diskettes
 in MFM recording mode and at the Double Density rate.
 However, ANNE emulates the PcW16, which also supports the High Density
 rate; and the system software depends on DD discs not being readable at
 the HD rate.
\end_layout

\begin_layout Standard
The extension gives meanings to two unused bytes of the DSK/EDSK 
\begin_inset Quotes eld
\end_inset

Track-Info
\begin_inset Quotes erd
\end_inset

 block:
\end_layout

\begin_layout Paragraph*
Byte 12h: Data rate.
 
\end_layout

\begin_layout Description
0 Unknown 
\end_layout

\begin_layout Description
1 Single or Double Density (180k, 720k, etc.) 
\end_layout

\begin_layout Description
2 High Density (1.2M, 1.4M, etc.) 
\end_layout

\begin_layout Description
3 Extended Density (2.8M)
\end_layout

\begin_layout Paragraph*
Byte 13h: Recording mode.
 
\end_layout

\begin_layout Description
0 Unknown 
\end_layout

\begin_layout Description
1 FM
\end_layout

\begin_layout Description
2 MFM
\end_layout

\begin_layout Standard
Existing files should have zeroes in these bytes; hence the use of 0 for
 Unknown.
 LibDsk will guess the values in if the ones in the file are zero.
\end_layout

\end_body
\end_document
